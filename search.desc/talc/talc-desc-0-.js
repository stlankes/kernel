searchState.loadedDescShard("talc", 0, "The Talc allocator crate.\nAn out-of-memory handler that attempts to claim the memory …\nDoesn’t handle out-of-memory conditions, immediate …\nRepresents an interval of memory <code>[base, acme)</code>\nThe Talc Allocator!\nTalc lock, contains a mutex-locked <code>Talc</code>.\nRaises <code>base</code> if <code>base</code> is smaller than <code>min</code>.\nLowers <code>acme</code> if <code>acme</code> is greater than <code>max</code>.\nAttempt to initialize a new heap for the allocator.\nReturns whether <code>self</code> contains <code>addr</code>.\nReturns whether <code>self</code> contains <code>other</code>.\nCreate an empty span.\nReturns the <code>Span</code>s of <code>self</code> below and above the <code>exclude</code> …\nIncrease the extent of a heap. The new extent of the heap …\nLower <code>base</code> by <code>low</code> and raise <code>acme</code> by <code>high</code>.\nReturns a span that contains <code>other</code> by extending <code>self</code>.\nReturns a span that <code>other</code> contains by raising <code>base</code> or …\nFree previously allocated/reallocated memory.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a <code>Span</code> given a <code>base</code> and a <code>size</code>.\nReturns the minimum <code>Span</code> containing this heap’s …\nIf <code>self</code> isn’t empty, returns <code>(base, acme)</code>\nGrow a previously allocated/reallocated region of memory …\nAttempt to grow a previously allocated/reallocated region …\nGiven the allocator and the <code>layout</code> of the allocation that …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRetrieve the inner <code>Talc</code>.\nReturns whether <code>base &gt;= acme</code>.\nReturns whether <code>base &lt; acme</code>.\nWrap in <code>Talck</code>, a mutex-locked wrapper struct using <code>lock_api</code>…\nLock the mutex and access the inner <code>Talc</code>.\nNote this only contains <code>AssumeUnlockable</code> which is not …\nAllocate a contiguous region of memory according to <code>layout</code>…\nSafety\nReturns an uninitialized <code>Talc</code>.\nCreate a new span.\nCreate a new <code>Talck</code>.\nThe user-specified OOM handler.\nReturns whether some of <code>self</code> overlaps with <code>other</code>.\nShrink a previously allocated/reallocated region of memory …\nReturns the size of the span, else zero if <code>base &gt;= span</code>.\nReturns <code>None</code> if <code>self</code> is empty.\nReturns <code>None</code> if <code>self</code> is empty.\nReduce the extent of a heap. The new extent must encompass …\nRaise <code>base</code> by <code>low</code> and lower <code>acme</code> by <code>high</code>.\nTry to lock the mutex and access the inner <code>Talc</code>.\nAligns <code>base</code> upward and <code>acme</code> downward by <code>align_of::&lt;usize&gt;()</code>…\nAligns <code>base</code> downward and <code>acme</code> upward by <code>align_of::&lt;usize&gt;()</code>…\nWARNING: <code>AssumeUnlockable</code> may cause undefined behaviour …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.")