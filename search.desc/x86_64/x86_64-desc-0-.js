searchState.loadedDescShard("x86_64", 0, "This crate provides x86_64 specific functions and data …\nRepresents a protection ring level.\nPrivilege-level 0 (most privilege): This level is used by …\nPrivilege-level 1 (moderate privilege): This level is used …\nPrivilege-level 2 (moderate privilege): Like level 1, this …\nPrivilege-level 3 (least privilege): This level is used by …\nPhysical and virtual addresses manipulation\nReturns the argument unchanged.\nCreates a <code>PrivilegeLevel</code> from a numeric value. The value …\nSpecial x86_64 instructions.\nCalls <code>U::from(self)</code>.\nAccess to various system and model specific registers.\nSet a general handler in an <code>InterruptDescriptorTable</code>.\nRepresentations of various x86 specific structures and …\nA 64-bit physical memory address.\nA passed <code>u64</code> was not a valid physical address.\nA canonical 64-bit virtual memory address.\nA passed <code>u64</code> was not a valid virtual address.\nAlign address downwards.\nAligns the virtual address downwards to the given …\nAligns the physical address downwards to the given …\nAlign address upwards.\nAligns the virtual address upwards to the given alignment.\nAligns the physical address upwards to the given alignment.\nConverts the address to a mutable raw pointer.\nConverts the address to a raw pointer.\nConverts the address to an <code>u64</code>.\nConverts the address to an <code>u64</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a virtual address from the given pointer\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nChecks whether the virtual address has the demanded …\nChecks whether the physical address has the demanded …\nConvenience method for checking if a virtual address is …\nConvenience method for checking if a physical address is …\nCreates a new canonical virtual address.\nCreates a new physical address.\nCreates a new canonical virtual address, throwing out bits …\nCreates a new physical address, throwing bits 52..64 away.\nCreates a new virtual address, without any checks.\nCreates a new physical address, without any checks.\nReturns the 9-bit level 1 page table index.\nReturns the 9-bit level 2 page table index.\nReturns the 9-bit level 3 page table index.\nReturns the 9-bit level 4 page table index.\nReturns the 12-bit page offset of this virtual address.\nReturns the 9-bit level page table index.\nTries to create a new canonical virtual address.\nTries to create a new physical address.\nCreates a virtual address that points to <code>0</code>.\nCreates a physical address that points to <code>0</code>.\nEmits a ‘magic breakpoint’ instruction for the Bochs …\nHalts the CPU until the next interrupt arrives.\nEnabling and disabling interrupts\nExecutes the <code>nop</code> instructions, which performs no operation …\nAccess to I/O ports\nSupport for build-in RNGs\nGets the current instruction pointer. Note that this is …\nProvides functions to read and write segment registers.\nFunctions to load GDT, IDT, and TSS structures.\nFunctions to flush the translation lookaside buffer (TLB).\nReturns whether interrupts are enabled.\nDisable interrupts.\nEnable interrupts.\nAtomically enable interrupts and put the CPU to sleep\nCause a breakpoint exception by invoking the <code>int3</code> …\nGenerate a software interrupt by invoking the <code>int</code> …\nRun a closure with disabled interrupts.\nA string representation for debug output.\nA read-write I/O port.\nA marker trait for access types which allow accessing port …\nAn I/O port.\nA marker trait for access types which allow reading port …\nA read-only I/O port.\nA marker trait for access types which allow writing port …\nA write-only I/O port.\nAn access marker type indicating that a port is only …\nAn access marker type indicating that a port is allowed to …\nAn access marker type indicating that a port is only …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates an I/O port with the given port number.\nReads from the port.\nWrites to the port.\nUsed to obtain random numbers using x86_64’s RDRAND …\nReturns the argument unchanged.\nUniformly sampled u16. May fail in rare circumstances or …\nUniformly sampled u32. May fail in rare circumstances or …\nUniformly sampled u64. May fail in rare circumstances or …\nCalls <code>U::from(self)</code>.\nCreates Some(RdRand) if RDRAND is supported, None otherwise\nLoad a GDT.\nLoad an IDT.\nLoad the task state register using the <code>ltr</code> instruction.\nGet the address of the current GDT.\nGet the address of the current IDT.\nThe logical processor invalidates mappings—except global …\nThe logical processor invalidates all mappings—including …\nThe logical processor invalidates all mappings—except …\nAn error returned when trying to use an invalid ASID.\nThe Invalidate PCID Command to execute.\nUsed to broadcast flushes to all logical processors.\nA builder struct to construct the parameters for the …\nStructure of a PCID. A PCID has to be &lt;= 4096 for x86_64.\nA passed <code>u16</code> was not a valid PCID.\nThe logical processor invalidates all mappings—except …\nOnly flush TLB entries with the given ASID.\nThe requested ASID.\nCreate a <code>InvlpgbFlushBuilder</code>.\nOnly flush the final translation and not the cached upper …\nInvalidate the given address in the TLB using the <code>invlpg</code> …\nExecute the flush.\nInvalidate the TLB completely by reloading the CR3 …\nInvalidate the given address in the TLB using the <code>invpcid</code> …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nAlso flush global pages.\nAlso flush nestred translations that could be used for …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the maximum count of pages to be flushed supported …\nReturns the number of available address space identifiers.\nThe number of valid ASIDS.\nCreate a new PCID. Will result in a failure if the value of\nCheck that <code>invlpgb</code> and <code>tlbsync</code> are supported and query …\nFlush a range of pages.\nOnly flush TLB entries with the given PCID.\nReturns whether the processor supports flushing …\nWait for all previous <code>invlpgb</code> instruction executed on the …\nGet the value of the current PCID.\nFunctions to read and write control registers.\nFunctions to read and write debug registers.\nFunctions to read and write model specific registers.\nFunctions to read and write MXCSR register.\nProcessor state stored in the RFLAGS register.\nAbstractions for segment registers.\nAccess to various extended system registers\nEnables automatic usermode alignment checking if […\nDisables some processor caches, specifics are …\nEnables Control-flow Enforcement Technology (CET)\nVarious control flags modifying the basic operation of the …\nConfiguration flags of the <code>Cr0</code> register.\nContains the Page Fault Linear Address (PFLA).\nContains the physical address of the highest-level page …\nControls cache settings for the highest-level page table.\nContains various control flags that enable architectural …\nConfiguration flags of the <code>Cr4</code> register.\nEnables I/O breakpoint capability and enforces treatment …\nForce all x87 and MMX instructions to cause an <code>#NE</code> …\nIndicates support of 387DX math coprocessor instructions.\nEnables software running in 64-bit mode at any privilege …\nEnables the Key Locker feature (Intel Only).\nEnables 5-level paging on supported CPUs (Intel Only).\nEnables the machine-check exception mechanism.\nEnables monitoring of the coprocessor, typical for x87 …\nIgnored, should always be unset.\nEnables the native (internal) error reporting mechanism …\nEnables the use of legacy SSE instructions; allows using …\nEnables the SIMD floating-point exception (<code>#XF</code>) for …\nEnables extended processor state management instructions, …\nEnables the global page feature, allowing some page …\nDisable caching for the table.\nUse a writethrough cache policy for the table (otherwise a …\nEnables the use of 4MB physical frames; ignored if …\nEnables paging.\nEnables process-context identifiers (PCIDs).\nAllows software running at any privilege level to use the …\nEnables physical address extensions and 2MB physical …\nEnables protected mode.\nEnables support for protected-mode virtual interrupts.\nEnables protection keys for supervisor-mode pages (Intel …\nEnables protection keys for user-mode pages.\nEnables SMX instructions (Intel Only).\nEnables restrictions for supervisor-mode software when …\nPrevents the execution of instructions that reside in …\nAutomatically set to 1 on <em>hardware</em> task switch.\nWhen set, only privilege-level 0 can execute the <code>RDTSC</code> or …\nPrevents the execution of the <code>SGDT</code>, <code>SIDT</code>, <code>SLDT</code>, <code>SMSW</code>, and …\nEnables hardware-supported performance enhancements for …\nEnables VMX instructions (Intel Only).\nControls whether supervisor-level writes to read-only …\nGet a flags value with all known bits set.\nGet a flags value with all known bits set.\nGet a flags value with all known bits set.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nGet the underlying bits value.\nGet the underlying bits value.\nGet the underlying bits value.\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nWhether all set bits in a source flags value are also set …\nWhether all set bits in a source flags value are also set …\nWhether all set bits in a source flags value are also set …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nGet a flags value with all bits unset.\nGet a flags value with all bits unset.\nGet a flags value with all bits unset.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert from a bits value.\nConvert from a bits value.\nConvert from a bits value.\nConvert from a bits value exactly.\nConvert from a bits value exactly.\nConvert from a bits value exactly.\nConvert from a bits value, unsetting any unknown bits.\nConvert from a bits value, unsetting any unknown bits.\nConvert from a bits value, unsetting any unknown bits.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nGet a flags value with the bits of a flag with the given …\nGet a flags value with the bits of a flag with the given …\nGet a flags value with the bits of a flag with the given …\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nWhether any set bits in a source flags value are also set …\nWhether any set bits in a source flags value are also set …\nWhether any set bits in a source flags value are also set …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether all known bits in this flags value are set.\nWhether all known bits in this flags value are set.\nWhether all known bits in this flags value are set.\nWhether all bits in this flags value are unset.\nWhether all bits in this flags value are unset.\nWhether all bits in this flags value are unset.\nYield a set of contained flags values.\nYield a set of contained flags values.\nYield a set of contained flags values.\nYield a set of contained named flags values.\nYield a set of contained named flags values.\nYield a set of contained named flags values.\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nRead the current set of CR0 flags.\nRead the current page fault linear address from the CR2 …\nRead the current P4 table address from the CR3 register.\nRead the current set of CR4 flags.\nRead the current P4 table address from the CR3 register …\nRead the current raw CR0 value.\nRead the current page fault linear address from the CR2 …\nRead the current P4 table address from the CR3 register\nRead the current raw CR4 value.\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nUpdates CR0 flags.\nUpdates CR4 flags.\nWrite CR0 flags.\nWrite a new P4 table address into the CR3 register.\nWrite CR4 flags.\nWrite a new P4 table address into the CR3 register.\nWrite a new P4 table address into the CR3 register without …\nWrite raw CR0 flags.\nWrite a new P4 table address into the CR3 register.\nWrite raw CR4 flags.\nNext instruction accesses one of the debug registers.\nThe condition for a hardware breakpoint.\nThe size of a hardware breakpoint.\nData reads or writes but not instruction fetches\nData writes\nDebug Address Register\nA valid debug address register number.\nDebug Address Register\nThe debug address register number of <code>Dr0</code> (0).\nDebug Address Register\nThe debug address register number of <code>Dr1</code> (1).\nDebug Address Register\nThe debug address register number of <code>Dr2</code> (2).\nDebug Address Register\nThe debug address register number of <code>Dr3</code> (3).\nDebug Status Register (DR6).\nDebug condition flags of the <code>Dr6</code> register.\nDebug Control Register (DR7).\nDebug control flags of the <code>Dr7</code> register.\nA valid value of the <code>Dr7</code> debug register.\nEnables debug register protection.\nBreakpoint 0 is enabled for all tasks.\nBreakpoint 1 is enabled for all tasks.\nBreakpoint 2 is enabled for all tasks.\nBreakpoint 3 is enabled for all tasks.\nEnable detection of exact instruction causing a data …\nInstruction execution\nI/O reads or writes\nBreakpoint 0 is enabled for the current task.\nBreakpoint 1 is enabled for the current task.\nBreakpoint 2 is enabled for the current task.\nBreakpoint 3 is enabled for the current task.\nEnable detection of exact instruction causing a data …\n1 byte length\n2 byte length\n4 byte length\n8 byte length\nThe corresponding <code>DebugAddressRegisterNumber</code>.\nEnables advanced debugging of RTM transactional regions.\nWhen <em>clear</em>, indicates a debug or breakpoint exception …\nCPU is in single-step execution mode.\nTask switch.\nBreakpoint condition was detected.\nBreakpoint condition 0 was detected.\nBreakpoint condition 1 was detected.\nBreakpoint condition 2 was detected.\nBreakpoint condition 3 was detected.\nGet a flags value with all known bits set.\nGet a flags value with all known bits set.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nGet the underlying bits value.\nGet the underlying bits value.\nReturns the raw value of the fields currently stored.\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nReturns the condition field of a debug address register.\nWhether all set bits in a source flags value are also set …\nWhether all set bits in a source flags value are also set …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nGet a flags value with all bits unset.\nGet a flags value with all bits unset.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nReturns the <code>Dr7Flags</code> in this value.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert from a bits value.\nConvert from a bits value.\nCreates a new hardware breakpoint condition if <code>bits</code> is …\nCreates a new hardware breakpoint size if <code>bits</code> is valid.\nConvert from underlying bit representation, unless that …\nConvert from a bits value exactly.\nConvert from a bits value exactly.\nConvert from a bits value, unsetting any unknown bits.\nConvert from a bits value, unsetting any unknown bits.\nConvert from underlying bit representation, dropping any …\nConvert from underlying bit representation, preserving all …\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nGet a flags value with the bits of a flag with the given …\nGet a flags value with the bits of a flag with the given …\nReturns the number as a primitive type.\nReturns the global breakpoint enable flag of the provided …\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nInserts the specified <code>Dr7Flags</code> in-place.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nWhether any set bits in a source flags value are also set …\nWhether any set bits in a source flags value are also set …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether all known bits in this flags value are set.\nWhether all known bits in this flags value are set.\nWhether all bits in this flags value are unset.\nWhether all bits in this flags value are unset.\nYield a set of contained flags values.\nYield a set of contained flags values.\nYield a set of contained named flags values.\nYield a set of contained named flags values.\nReturns the local breakpoint enable flag of the provided …\nCreates a debug address register number if it is valid.\nCreates a new hardware breakpoint size if <code>size</code> is valid.\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nReads the current breakpoint address.\nRead the current set of DR6 flags.\nRead the current set of DR7 flags.\nRead the current raw DR6 value.\nRead the current raw DR7 value.\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nRemoves the specified <code>Dr7Flags</code> in-place.\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nSets the condition field of a debug address register.\nInserts or removes the specified <code>Dr7Flags</code> depending on the …\nSets the size field of a debug address register.\nReturns the size field of a debug address register.\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nToggles the specified <code>Dr7Flags</code> in-place.\nReturns the trap flag of the provided debug address …\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nWrites the provided breakpoint address.\nWrite DR7 value.\nWrite raw DR7 value.\nFlags stored in IA32_U_CET and IA32_S_CET (Table-2-2 in …\nThe Extended Feature Enable Register.\nFlags of the Extended Feature Enable Register.\nEnable the <code>fxsave</code> and <code>fxrstor</code> instructions to execute …\nFS.Base Model Specific Register.\nGS.Base Model Specific Register.\nEnable indirect branch tracking (ENDBR_EN)\nEnable legacy treatment for indirect branch tracking …\nDisable suppression of CET on legacy compatibility …\nEnable no-track opcode prefix for indirect branch tracking …\nEnable suppression of indirect branch tracking (SUPPRESS)\nIs IBT waiting for a branch to return? (read-only, TRACKER)\nKernelGsBase Model Specific Register.\nIndicates that long mode is active.\nActivates long mode, requires activating paging.\nEnable certain limit checks in 64-bit mode.\nSyscall Register: LSTAR\nThe underlying model specific register.\nThe underlying model specific register.\nThe underlying model specific register.\nThe underlying model specific register.\nThe underlying model specific register.\nThe underlying model specific register.\nThe underlying model specific register.\nThe underlying model specific register.\nThe underlying model specific register.\nA model specific register.\nEnables the no-execute page-protection feature.\nIA32_S_CET: supervisor mode CET configuration\nEnables SVM extensions.\nSyscall Register: SFMASK\nEnable shadow stack (SH_STK_EN)\nEnable WRSS{D,Q}W instructions (WR_SHTK_EN)\nEnables the <code>syscall</code> and <code>sysret</code> instructions.\nSyscall Register: STAR\nChanges how the <code>invlpg</code> instruction operates on TLB entries …\nIA32_U_CET: user mode CET configuration\nGet a flags value with all known bits set.\nGet a flags value with all known bits set.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nGet the underlying bits value.\nGet the underlying bits value.\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nWhether all set bits in a source flags value are also set …\nWhether all set bits in a source flags value are also set …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nGet a flags value with all bits unset.\nGet a flags value with all bits unset.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert from a bits value.\nConvert from a bits value.\nConvert from a bits value exactly.\nConvert from a bits value exactly.\nConvert from a bits value, unsetting any unknown bits.\nConvert from a bits value, unsetting any unknown bits.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nGet a flags value with the bits of a flag with the given …\nGet a flags value with the bits of a flag with the given …\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nWhether any set bits in a source flags value are also set …\nWhether any set bits in a source flags value are also set …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether all known bits in this flags value are set.\nWhether all known bits in this flags value are set.\nWhether all bits in this flags value are unset.\nWhether all bits in this flags value are unset.\nYield a set of contained flags values.\nYield a set of contained flags values.\nYield a set of contained named flags values.\nYield a set of contained named flags values.\nCreate an instance from a register.\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nRead 64 bits msr register.\nRead the current EFER flags.\nRead the current FsBase register.\nRead the current GsBase register.\nRead the current KernelGsBase register.\nRead the Ring 0 and Ring 3 segment bases. Returns\nRead the current LStar register. This holds the target RIP …\nRead to the SFMask register. The SFMASK register is used …\nRead IA32_U_CET. Returns a tuple of the flags and the …\nRead IA32_S_CET. Returns a tuple of the flags and the …\nRead the current raw EFER flags.\nRead the Ring 0 and Ring 3 segment bases. The remaining …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nUpdate EFER flags.\nWrite 64 bits to msr register.\nWrite the EFER flags, preserving reserved values.\nWrite a given virtual address to the FS.Base register.\nWrite a given virtual address to the GS.Base register.\nWrite a given virtual address to the KernelGsBase register.\nWrite the Ring 0 and Ring 3 segment bases. The remaining …\nWrite a given virtual address to the LStar register. This …\nWrite to the SFMask register. The SFMASK register is used …\nWrite IA32_U_CET.\nWrite IA32_S_CET.\nWrite the EFER flags.\nWrite the Ring 0 and Ring 3 segment bases. The remaining …\nDenormal\nDenormals are zeros\nDenormal mask\nDivide-by-zero\nDivide-by-zero mask\nFlush to zero\nInvalid operation\nInvalid operation mask\nMXCSR register.\nOverflow\nOverflow mask\nPrecision\nPrecision mask\nToward negative infinity\nToward positive infinity\nToward zero (positive + negative)\nUnderflow\nUnderflow mask\nGet a flags value with all known bits set.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nGet the underlying bits value.\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nWhether all set bits in a source flags value are also set …\nReturn the default MXCSR value at reset, as documented in …\nThe intersection of a source flags value with the …\nGet a flags value with all bits unset.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nReturns the argument unchanged.\nConvert from a bits value.\nConvert from a bits value exactly.\nConvert from a bits value, unsetting any unknown bits.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nGet a flags value with the bits of a flag with the given …\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nWhether any set bits in a source flags value are also set …\nCalls <code>U::from(self)</code>.\nWhether all known bits in this flags value are set.\nWhether all bits in this flags value are unset.\nYield a set of contained flags values.\nYield a set of contained named flags values.\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nRead the value of MXCSR.\nThe intersection of a source flags value with the …\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nWrite MXCSR.\nEnable automatic alignment checking if CR0.AM is set. Only …\nSet by hardware if last arithmetic operation generated a …\nSet by hardware if last arithmetic operation generated a …\nDetermines the order in which strings are processed.\nProcessor feature identification flag.\nEnable interrupts.\nThe high bit of the I/O Privilege Level field.\nThe low bit of the I/O Privilege Level field.\nUsed by <code>iret</code> in hardware task switch mode to determine if …\nSet by hardware to indicate that the sign bit of the …\nSet by hardware if last result has an even number of 1 …\nAllows to restart an instruction following an instruction …\nThe RFLAGS register. All bit patterns are valid …\nSet by hardware if last arithmetic operation resulted in a …\nEnable single-step mode for debugging.\nEnable the virtual-8086 mode.\nVirtual image of the INTERRUPT_FLAG bit.\nIndicates that an external, maskable interrupt is pending.\nSet by hardware if last arithmetic operation resulted in a …\nGet a flags value with all known bits set.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nGet the underlying bits value.\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nWhether all set bits in a source flags value are also set …\nThe intersection of a source flags value with the …\nGet a flags value with all bits unset.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nReturns the argument unchanged.\nConvert from a bits value.\nConvert from a bits value exactly.\nConvert from a bits value, unsetting any unknown bits.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nGet a flags value with the bits of a flag with the given …\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nWhether any set bits in a source flags value are also set …\nCalls <code>U::from(self)</code>.\nWhether all known bits in this flags value are set.\nWhether all bits in this flags value are unset.\nYield a set of contained flags values.\nYield a set of contained named flags values.\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nReturns the current value of the RFLAGS register.\nReturns the raw current value of the RFLAGS register.\nThe intersection of a source flags value with the …\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nWrites the RFLAGS register, preserves reserved bits.\nWrites the RFLAGS register.\nMSR containing the segment base. This MSR can be used to …\nCode Segment\nData Segment\nES Segment\nFS Segment\nGS Segment\nCan be used as a selector into a non-existent segment and …\nStack Segment\nAn x86 segment\nAn x86 segment which is actually used in 64-bit mode\nSpecifies which element to load into a segment from …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the current value of the segment register.\nReturns the GDT index.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates a new SegmentSelector\nReads the segment base address\nReturns the requested privilege level.\nReload the segment register. Depending on the segment, …\nNote this is special since we cannot directly move to <code>CS</code>; …\nSet the privilege level for this Segment selector.\nSwap <code>KernelGsBase</code> MSR and <code>GsBase</code> MSR.\nWrites the segment base address\nEnables AVX instructions and using the upper halves of the …\nEnables MPX instructions and using the BNDCFGU and …\nEnables MPX instructions and using the BND0-BND3 bound …\nEnables AVX-512 instructions and using the upper ZMM …\nEnables Lightweight Profiling extensions and managing LWP …\nEnables using the PKRU register with <code>XSAVE</code>/<code>XRSTOR</code>.\nEnables AVX-512 instructions and using the K0-K7 mask …\nEnables using MXCSR and the XMM registers with <code>XSAVE</code>/<code>XRSTOR</code>…\nEnables using the x87 FPU state with <code>XSAVE</code>/<code>XRSTOR</code>.\nExtended feature enable mask register\nConfiguration flags of the XCr0 register.\nEnables AVX-512 instructions and using the upper halves of …\nGet a flags value with all known bits set.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nGet the underlying bits value.\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nWhether all set bits in a source flags value are also set …\nThe intersection of a source flags value with the …\nGet a flags value with all bits unset.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert from a bits value.\nConvert from a bits value exactly.\nConvert from a bits value, unsetting any unknown bits.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nGet a flags value with the bits of a flag with the given …\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nWhether any set bits in a source flags value are also set …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether all known bits in this flags value are set.\nWhether all bits in this flags value are unset.\nYield a set of contained flags values.\nYield a set of contained named flags values.\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nRead the current set of XCR0 flags.\nRead the current raw XCR0 value.\nThe intersection of a source flags value with the …\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nWrite XCR0 flags.\nWrite raw XCR0 flags.\nA struct describing a pointer to a descriptor table (GDT / …\nPointer to the memory region containing the DT.\nReturns the argument unchanged.\nTypes for the Global Descriptor Table and segment …\nProvides types for the Interrupt Descriptor Table and its …\nCalls <code>U::from(self)</code>.\nSize of the DT in bytes - 1.\nAbstractions for page tables and other paging related …\nTraits for accessing I/O ports.\nProvides a type for the task state segment structure.\nSet by the processor if this segment has been accessed. …\nAvailable for use by the Operating System\nBits <code>0..=23</code> of the base field (ignored in 64-bit mode, …\nBits <code>24..=31</code> of the base field (ignored in 64-bit mode, …\nFor code segments, sets the segment as “conforming”, …\nUse 32-bit (as opposed to 16-bit) operands. If <code>LONG_MODE</code> …\nThese two bits encode the Descriptor Privilege Level (DPL) …\nA 64-bit mode segment descriptor.\nFlags for a GDT descriptor. Not all flags are valid for …\nThis flag must be set for code segments and unset for data …\n8-byte entry in a descriptor table.\nLimit field is scaled by 4096 bytes. In 64-bit mode, …\nA 64-bit mode global descriptor table (GDT).\nA flat 32-bit kernel code segment\nA 64-bit kernel code segment\nA kernel data segment (64-bit or flat 32-bit)\nBits <code>0..=15</code> of the limit field (ignored in 64-bit mode)\nBits <code>16..=19</code> of the limit field (ignored in 64-bit mode)\nMust be set for 64-bit code segments, unset otherwise.\nMust be set for any segment, causes a segment not present …\nA system segment descriptor such as a LDT or TSS …\nA flat 32-bit user code segment\nA 64-bit user code segment\nA user data segment (64-bit or flat 32-bit)\nThis flag must be set for user segments (in contrast to …\nDescriptor for a code or data segment.\nFor 32-bit data segments, sets the segment as writable. …\nGet a flags value with all known bits set.\nAppends the given segment descriptor to the GDT, returning …\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nGet the underlying bits value.\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nWhether all set bits in a source flags value are also set …\nThe intersection of a source flags value with the …\nReturns the Descriptor Privilege Level (DPL). When using …\nCreates an empty GDT which can hold <code>MAX</code> number of <code>Entry</code>s.\nGet a flags value with all bits unset.\nGet a reference to the internal <code>Entry</code> table.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert from a bits value.\nConvert from a bits value exactly.\nConvert from a bits value, unsetting any unknown bits.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nGet a flags value with the bits of a flag with the given …\nForms a GDT from a slice of <code>u64</code>.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nWhether any set bits in a source flags value are also set …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether all known bits in this flags value are set.\nWhether all bits in this flags value are unset.\nYield a set of contained flags values.\nYield a set of contained named flags values.\nCreates a segment descriptor for a 64-bit kernel code …\nCreates a segment descriptor for a kernel data segment …\nReturns the value of the limit for a gdt pointer. It is …\nLoads the GDT in the CPU using the <code>lgdt</code> instruction. This …\nLoads the GDT in the CPU using the <code>lgdt</code> instruction. This …\nCreates an empty GDT with the default length of 8.\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe raw bits for this entry. Depending on the <code>Descriptor</code> …\nThe intersection of a source flags value with the …\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nCreates a TSS system descriptor for the given TSS.\nSimilar to <code>Descriptor::tss_segment</code>, but unsafe since it …\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nCreates a segment descriptor for a 64-bit ring 3 code …\nCreates a segment descriptor for a ring 3 data segment …\nAlignment Check\nBound Range Exceeded\nBreakpoint\nIf this flag is set, the memory access that caused the …\nControl Protection Exception\nDebug\nThe possible descriptor table values.\nDevice Not Available\nA handler function that must not return, e.g. for a …\nA handler function with an error code that must not …\nError during Division\nDouble Fault\nAn Interrupt Descriptor Table entry.\nRepresents the 4 non-offset bytes of an IDT entry.\nThis structure defines the CPU-internal exception vector …\nGlobal Descriptor Table.\nA general handler function for an interrupt or an …\nGeneral Protection Fault\nA handler function for an interrupt or an exception …\nA common trait for all handler functions usable in <code>Entry</code>.\nA handler function for an exception that pushes an error …\nHypervisor Injection (AMD-only)\nIf this flag is set, it indicates that the access that …\nInterrupt Descriptor Table.\nAn Interrupt Descriptor Table with 256 entries.\nWrapper type for the interrupt stack frame pushed by the …\nRepresents the interrupt stack frame pushed by the CPU on …\nException vector number is invalid\nInvalid Opcode\nInvalid TSS\nLogical Descriptor Table.\nIf this flag is set, the page fault is a result of the …\nMachine Check\nNon-Maskable Interrupt\nOverflow\nIf this flag is set, it indicates that the page fault was …\nIf this flag is set, the page fault was caused by a …\nPage Fault\nDescribes an page fault error code.\nA page fault handler function that pushes a page fault …\nIf this flag is set, it indicates that the page fault is a …\nIf this flag is set, it indicates that the page fault was …\nIf this flag is set, it indicates that the page fault was …\nSecurity Exception\nSegment Not Present\nDescribes an error code referencing a segment selector.\nSIMD Floating-Point Exception\nStack Fault\nIf this flag is set, an access in user mode (CPL=3) caused …\nVirtualization Exception (Intel-only)\nVMM Communication (AMD-only)\nx87 Floating-Point Exception\nAn alignment check exception (<code>#AC</code>) occurs when an …\nGet a flags value with all known bits set.\nGives mutable access to the contents of the interrupt …\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nGet the underlying bits value.\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nA bound-range exception (<code>#BR</code>) exception can occur as a …\nA breakpoint (<code>#BP</code>) exception occurs when an <code>INT3</code> …\nThe code segment selector at the time of the interrupt.\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nWhether all set bits in a source flags value are also set …\nA #CP exception is generated when shadow stacks are …\nThe flags register before the interrupt handler was …\nWhen the debug-exception mechanism is enabled, a <code>#DB</code> …\nThe descriptor table this error code refers to.\nA device not available exception (<code>#NM</code>) occurs under any of …\nThe intersection of a source flags value with the …\nLet the CPU disable hardware interrupts when the handler …\nA divide error (<code>#DE</code>) occurs when the denominator of a DIV …\nA double fault (<code>#DF</code>) exception can occur when a second …\nGet a flags value with all bits unset.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nIf true, indicates that the exception occurred during …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert from a bits value.\nConvert from a bits value exactly.\nConvert from a bits value, unsetting any unknown bits.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nGet a flags value with the bits of a flag with the given …\nA general protection fault (<code>#GP</code>) can occur in various …\nReturns the virtual address of this IDT entry’s handler …\nThe Hypervisor Injection Exception (<code>#HV</code>) is injected by a …\nReturns the IDT entry with the specified index.\nReturns the IDT entry with the specified index.\nReturns the IDT entry with the specified index.\nReturns the IDT entry with the specified index.\nReturns the IDT entry with the specified index.\nReturns the IDT entry with the specified index.\nReturns the IDT entry with the specified index.\nReturns the IDT entry with the specified index.\nReturns the IDT entry with the specified index.\nReturns the IDT entry with the specified index.\nReturns the IDT entry with the specified index.\nReturns the IDT entry with the specified index.\nReturns the IDT entry with the specified index.\nReturns the IDT entry with the specified index.\nThe index of the selector which caused the error.\nReturns a mutable reference to the IDT entry with the …\nReturns a mutable reference to the IDT entry with the …\nReturns a mutable reference to the IDT entry with the …\nReturns a mutable reference to the IDT entry with the …\nReturns a mutable reference to the IDT entry with the …\nReturns a mutable reference to the IDT entry with the …\nReturns a mutable reference to the IDT entry with the …\nReturns a mutable reference to the IDT entry with the …\nReturns a mutable reference to the IDT entry with the …\nReturns a mutable reference to the IDT entry with the …\nReturns a mutable reference to the IDT entry with the …\nReturns a mutable reference to the IDT entry with the …\nReturns a mutable reference to the IDT entry with the …\nReturns a mutable reference to the IDT entry with the …\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThis value points to the instruction that should be …\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nWhether any set bits in a source flags value are also set …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAn invalid opcode exception (<code>#UD</code>) occurs when an attempt …\nAn invalid TSS exception (<code>#TS</code>) occurs only as a result of …\nCall the <code>iretq</code> (interrupt return) instruction.\nWhether all known bits in this flags value are set.\nWhether all bits in this flags value are unset.\nIf true, the #SS or #GP has returned zero as opposed to a …\nYield a set of contained flags values.\nYield a set of contained named flags values.\nLoads the IDT in the CPU using the <code>lidt</code> command.\nLoads the IDT in the CPU using the <code>lidt</code> command.\nThe machine check exception (<code>#MC</code>) is model specific. …\nCreates a non-present IDT entry (but sets the must-be-one …\nCreates a new interrupt stack frame with the given values.\nCreates a new IDT filled with non-present entries.\nCreates a new interrupt stack frame with the given values.\nCreate a SelectorErrorCode. Returns None is any of the …\nCreate a new SelectorErrorCode dropping any reserved bits …\nAn non maskable interrupt exception (NMI) occurs as a …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nAn overflow exception (<code>#OF</code>) occurs as a result of …\nA page fault (<code>#PF</code>) can occur during a memory access in any …\nThe intersection of a source flags value with the …\nResets all entries of this IDT in place.\nThe Security Exception (<code>#SX</code>) signals security-sensitive …\nAn segment-not-present exception (<code>#NP</code>) occurs when an …\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nSet the code segment that will be used by this interrupt.\nSets the handler address for the IDT entry and sets the …\nSets the handler function for the IDT entry and sets the …\nSet or reset the preset bit.\nSet the required privilege level (DPL) for invoking the …\nAssigns a Interrupt Stack Table (IST) stack to this …\nThe SIMD Floating-Point Exception (<code>#XF</code>) is used to handle …\nReturns slice of IDT entries with the specified range.\nReturns a mutable slice of IDT entries with the specified …\nThe stack pointer at the time of the interrupt.\nThe stack segment descriptor at the time of the interrupt …\nAn stack segment exception (<code>#SS</code>) can occur in the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nGet the virtual address of the handler function.\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nTries to convert the exception vector number to …\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nvector nr. 20\nThe VMM Communication Exception (<code>#VC</code>) is always generated …\nThe x87 Floating-Point Exception-Pending exception (<code>#MF</code>) …\nA trait for types that can allocate a frame of memory.\nA trait for types that can deallocate a frame of memory.\nAllocate a frame of the appropriate size and return it if …\nDeallocate the given unused frame.\nAbstractions for default-sized and huge physical memory …\nAbstractions for reading and modifying the mapping of …\nAbstractions for default-sized and huge virtual memory …\nAbstractions for page tables and page table entries.\nA physical memory frame.\nAn range of physical memory frames, exclusive the upper …\nAn range of physical memory frames, inclusive the upper …\nReturns the frame that contains the given physical address.\nThe end of the range, exclusive.\nThe start of the range, inclusive.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the frame that starts at the given virtual address.\nReturns the frame that starts at the given virtual address.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns whether the range contains no frames.\nReturns whether the range contains no frames.\nReturns the number of frames in the range.\nReturns the number of frames in the range.\nReturns a range of frames, exclusive <code>end</code>.\nReturns a range of frames, inclusive <code>end</code>.\nReturns the size the frame (4KB, 2MB or 1GB).\nReturns the size in bytes of all frames within the range.\nReturns the size in bytes of all frames within the range.\nThe start of the range, inclusive.\nThe start of the range, inclusive.\nReturns the start address of the frame.\nProvides methods for cleaning up unused entries.\nAn error indicating that an <code>update_flags</code> call failed.\nAn additional frame was needed for the mapping process, …\nThe page table entry for the given virtual address points …\nThe page table entry for the given page points to an …\nThe page table entry for the given page points to an …\nThe given page table was not suitable to create a …\nThis error is returned from <code>map_to</code> and similar methods.\nThe virtual address is mapped to a physical frame.\nRepresents a physical frame mapped in a page table.\nA Mapper implementation that relies on a PhysAddr to …\nA trait for common page table operations on pages of size <code>S</code>…\nAn empty convencience trait that requires the <code>Mapper</code> trait …\nThis type represents a page whose mapping has changed in …\nThis type represents a change of a page table requiring a …\nThe given page table was not active on the CPU.\nThe given virtual address is not mapped to a physical …\nThe given page table was not at an recursive address.\nA Mapper implementation that requires that the complete …\nThe given page is already mapped to a physical frame.\nThe given page is not mapped to a physical frame.\nThe given page is not mapped to a physical frame.\nThe given page is not mapped to a physical frame.\nProvides a virtual address mapping for physical page table …\nAn upper level page table entry has the <code>HUGE_PAGE</code> flag …\nAn upper level page table entry has the <code>HUGE_PAGE</code> flag …\nAn upper level page table entry has the <code>HUGE_PAGE</code> flag …\nAn upper level page table entry has the <code>HUGE_PAGE</code> flag …\nA recursive page table is a last level page table with an …\nThe virtual address is mapped to a “huge” 1GiB frame.\nThe virtual address is mapped to a “large” 2MiB frame.\nThe virtual address is mapped to a 4KiB frame.\nProvides methods for translating virtual addresses.\nAn error indicating that an <code>translate</code> call failed.\nThe return value of the <code>Translate::translate</code> function.\nAn error indicating that an <code>unmap</code> call failed.\nRemove all empty P1-P3 tables\nRemove all empty P1-P3 tables in a certain range\nFlush the page from the TLB to ensure that the newest …\nFlush all pages from the TLB to ensure that the newest …\nTranslate the given physical frame to a virtual page table …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nMaps the given frame to the virtual page with the same …\nDon’t flush the TLB and silence the “must be used” …\nDon’t flush the TLB and silence the “must be used” …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns an immutable reference to the wrapped level 4 …\nReturns an immutable reference to the wrapped level 4 …\nReturns an immutable reference to the wrapped level 4 …\nReturns a mutable reference to the wrapped level 4 …\nReturns a mutable reference to the wrapped level 4 …\nReturns a mutable reference to the wrapped level 4 …\nCreates a new mapping in the page table.\nCreates a new mapping in the page table.\nCreates a new <code>MappedPageTable</code> that uses the passed …\nCreates a new <code>OffsetPageTable</code> that uses the given offset …\nCreates a new RecursivePageTable from the passed level 4 …\nCreate a new flush promise\nCreate a new flush promise\nCreates a new RecursivePageTable without performing any …\nReturns the <code>PageTableFrameMapping</code> used for converting …\nReturns the offset used for converting virtual to physical …\nSet the flags of an existing page table level 2 entry\nSet the flags of an existing page table level 3 entry\nSet the flags of an existing page level 4 table entry\nReturns the size the frame (4KB, 2MB or 1GB).\nReturns the start address of the frame.\nReturn the frame that the given virtual address is mapped …\nTranslates the given virtual address to the physical …\nReturn the frame that the specified page is mapped to.\nRemoves a mapping from the page table and returns the …\nUpdates the flags of an existing mapping.\nThe entry flags in the lowest-level page table.\nThe mapped frame.\nThe offset within the mapped frame.\nThe given address was not sufficiently aligned.\nA string representation of the page size for debug output.\nThis trait is implemented for 4KiB and 2MiB pages, but not …\nA virtual memory page.\nA range of pages with exclusive upper bound.\nA range of pages with inclusive upper bound.\nTrait for abstracting over the three possible page sizes …\nThe page size in bytes.\nThe page size in bytes.\nA “giant” 1GiB page.\nA “huge” 2MiB page.\nA standard 4KiB page.\nConverts the range of 2MiB pages to a range of 4KiB pages.\nReturns the page that contains the given virtual address.\nThe end of the range, exclusive.\nThe end of the range, inclusive.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the 4KiB memory page with the specified page table …\nReturns the 1GiB memory page with the specified page table …\nReturns the 2MiB memory page with the specified page table …\nReturns the page that starts at the given virtual address.\nReturns the page that starts at the given virtual address.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns wether this range contains no pages.\nReturns whether this range contains no pages.\nReturns the number of pages in the range.\nReturns the number of frames in the range.\nReturns the level 1 page table index of this page.\nReturns the level 2 page table index of this page.\nReturns the level 3 page table index of this page.\nReturns the level 4 page table index of this page.\nReturns the table index of this page at the specified …\nReturns a range of pages, exclusive <code>end</code>.\nReturns a range of pages, inclusive <code>end</code>.\nReturns the size the page (4KB, 2MB or 1GB).\nReturns the size in bytes of all pages within the range.\nReturns the size in bytes of all frames within the range.\nThe start of the range, inclusive.\nThe start of the range, inclusive.\nReturns the start address of the page.\nSet by the CPU when the mapped frame or page table is …\nAvailable to the OS, can be used to store additional data, …\nAvailable to the OS, can be used to store additional data, …\nAvailable to the OS, can be used to store additional data, …\nAvailable to the OS, can be used to store additional data, …\nAvailable to the OS, can be used to store additional data, …\nAvailable to the OS, can be used to store additional data, …\nAvailable to the OS, can be used to store additional data, …\nAvailable to the OS, can be used to store additional data, …\nAvailable to the OS, can be used to store additional data, …\nAvailable to the OS, can be used to store additional data, …\nAvailable to the OS, can be used to store additional data, …\nAvailable to the OS, can be used to store additional data, …\nAvailable to the OS, can be used to store additional data, …\nAvailable to the OS, can be used to store additional data, …\nSet by the CPU on a write to the mapped frame.\nRepresents the level for a page-map level-4.\nThe error returned by the <code>PageTableEntry::frame</code> method.\nThe entry does not have the <code>PRESENT</code> flag set, so it isn’…\nIndicates that the mapping is present in all address …\nSpecifies that the entry maps a huge frame instead of a …\nThe entry does have the <code>HUGE_PAGE</code> flag set. The <code>frame</code> …\nDisables caching for the pointed entry is cacheable.\nForbid code execution from the mapped frames.\nRepresents the level for a page table.\nSpecifies whether the mapped frame or page table is loaded …\nA 12-bit offset into a 4KiB Page.\nRepresents a page table.\nA 64-bit page table entry.\nPossible flags for a page table entry.\nA 9-bit index into a page table.\nA value between 1 and 4.\nRepresents the level for a page-directory pointer.\nRepresents the level for a page directory.\nControls whether accesses from userspace (i.e. ring 3) are …\nControls whether writes to the mapped frames are allowed.\nIf this bit is set, a “write-through” policy is used …\nReturns the physical address mapped by this entry, might …\nGet a flags value with all known bits set.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nGet the underlying bits value.\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nWhether all set bits in a source flags value are also set …\nThe intersection of a source flags value with the …\nGet a flags value with all bits unset.\nReturns the alignment for the address space described by …\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nReturns the flags of this entry.\nReturns the physical frame mapped by this entry.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert from a bits value.\nConvert from a bits value exactly.\nConvert from a bits value, unsetting any unknown bits.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nGet a flags value with the bits of a flag with the given …\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nWhether any set bits in a source flags value are also set …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether all known bits in this flags value are set.\nWhether all bits in this flags value are unset.\nChecks if the page table is empty (all entries are zero).\nReturns whether this entry is zero.\nYield a set of contained flags values.\nReturns an iterator over the entries of the page table.\nReturns an iterator that allows modifying the entries of …\nYield a set of contained named flags values.\nCreates an unused page table entry.\nCreates an empty page table.\nCreates a new index from the given <code>u16</code>. Panics if the …\nCreates a new offset from the given <code>u16</code>. Panics if the …\nCreates a new index from the given <code>u16</code>. Throws away bits …\nCreates a new offset from the given <code>u16</code>. Throws away bits …\nReturns the next higher level or <code>None</code> for level 4\nReturns the next lower level or <code>None</code> for level 1\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe intersection of a source flags value with the …\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nMap the entry to the specified physical address with the …\nSets the flags of this entry.\nMap the entry to the specified physical frame with the …\nSets this entry to zero.\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nReturns the alignment for the address space described by a …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nClears all entries.\nA helper trait that implements the read port operation.\nA helper trait that implements the write port operation.\nReads a <code>Self</code> value from the given port.\nWrites a <code>Self</code> value to the given port.\nIn 64-bit mode the TSS holds information that is not …\nReturns the argument unchanged.\nThe full 64-bit canonical forms of the interrupt stack …\nCalls <code>U::from(self)</code>.\nThe 16-bit offset to the I/O permission bit map from the …\nCreates a new TSS with zeroed privilege and interrupt …\nThe full 64-bit canonical forms of the stack pointers …")