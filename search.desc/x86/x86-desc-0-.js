searchState.loadedDescShard("x86", 0, "x86 Protection levels\nRegister information and driver to program xAPIC, X2APIC …\nData structures and functions used by 16-bit mode.\nData structures and functions used by 32-bit mode.\nData structures and functions used by IA-32e but not …\nFunctions to read and write control registers. See Intel …\nSupport for the CPUID instructions.\nA short-cut to the architecture (bits32 or bits64) this …\nFunctions to read and write debug registers.\nFunctions and data-structures for working with descriptor …\nIntel fence instructions\nReturns the argument unchanged.\n“Dereferences” the fs register at <code>offset</code>.\n“Dereferences” the gs register at <code>offset</code>.\nStops instruction execution and places the processor in a …\nGenerate a software interrupt. This is a macro argument …\nCalls <code>U::from(self)</code>.\nI/O port functionality.\nShared interrupt description and set-up code. See the …\nMSR value list and function to read and write them.\nInstructions to generate random bits directly from the …\nRead Processor ID\nFunctionality to manipulate segment registers, build …\nHelpers to program the task state segment. See Intel 3a, …\nFunctions to read time stamp counters on x86.\nFunctions to flush the translation lookaside buffer (TLB).\nData structures and definitions used by Virtual Machine …\nAbstracts common interface of local APIC (x2APIC, xAPIC) …\nEncodes the id of a core.\nSpecify IPI Delivery Mode\nSpecify Delivery Status\nSpecify IPI Destination Mode.\nIPI Destination Shorthand\nDelivers the interrupt specified in the vector field to …\nAbstract the IPI control register\nDelivers an INIT request to the target processor or …\nIPI Level\nSame as fixed mode, except that the interrupt is delivered …\nDelivers an NMI interrupt to the target processor or …\nDelivers an SMI interrupt to the target processor or …\nSends a special start-up IPI (called a SIPI) to the target …\nIPI Trigger Mode\nA core destination encoded as an x2APIC ID.\nA core destination encoded as an xAPIC ID.\nReserved\nIs a bootstrap processor?\nEnd Of Interrupt – Acknowledge interrupt delivery.\nShort-hand to create a Icr value that will work for an …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturn APIC ID.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTo control an I/O APIC.\nSend a INIT IPI to a core.\nDeassert INIT IPI.\nSend a STARTUP IPI to a core.\nReturns the logical APIC ID.\nGet lower 32-bits of the Icr register.\nSend a generic IPI.\nEnable TSC deadline timer.\nSet TSC deadline value.\nGet upper 32-bits of the Icr register.\nRead APIC version\nx2APIC, the most recent APIC on x86 for large servers with …\nReturns the logical address relative to a cluster for a …\nReturns the cluster ID a given APIC ID belongs to …\nReturns the Logical x2APIC ID.\nInformation about the xAPIC for the local APIC.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nInstantiate a new IoApic.\nNumber of supported interrupts by this IO APIC.\nRepresents an x2APIC driver instance.\nAttach to APIC (enable x2APIC mode, initialize LINT0)\nIs a bootstrap processor?\nDetach from APIC (disable x2APIC and xAPIC mode).\nEnd Of Interrupt – Acknowledge interrupt delivery.\nReturns the argument unchanged.\nRead local x2APIC ID.\nCalls <code>U::from(self)</code>.\nSend a INIT IPI to a core.\nDeassert INIT IPI.\nSend a STARTUP IPI to a core.\nIn x2APIC mode, the 32-bit logical x2APIC ID, can be read …\nCreate a new x2APIC driver object for the local core.\nSend a generic IPI.\nSend an IPI to yourself.\nEnable TSC timer\nSet tsc deadline.\nRead APIC version.\nState for the XAPIC driver.\nEOI register. Write-only.\nError Status Register (ESR). Read/write. See Section …\nInterrupt Command Register (ICR). Read/write. See Figure …\nInterrupt Command Register (ICR). Read/write. See Figure …\nLocal APIC ID register. Read-only. See Section 10.12.5.1 …\nInterrupt Request Register (IRR); bits 31:0. Read-only.\nIRR bits 63:32. Read-only.\nIRR bits 95:64. Read-only.\nIRR bits 127:96. Read-only.\nIRR bits 159:128. Read-only.\nIRR bits 191:160. Read-only.\nIRR bits 223:192. Read-only.\nIRR bits 255:224. Read-only.\nIn-Service Register (ISR); bits 31:0. Read-only.\nISR bits 63:32. Read-only.\nISR bits 95:64. Read-only.\nISR bits 127:96. Read-only.\nISR bits 159:128. Read-only.\nISR bits 191:160. Read-only.\nISR bits 223:192. Read-only.\nISR bits 255:224. Read-only.\nLogical Destination Register (LDR). Read/write in xAPIC …\nLVT CMCI register. Read/write. See Figure 10-8 for …\nLVT Error register. Read/write. See Figure 10-8 for …\nLVT LINT0 register. Read/write. See Figure 10-8 for …\nLVT LINT1 register. Read/write. See Figure 10-8 for …\nLVT Performance Monitoring register. Read/write. See …\nLVT Thermal Sensor register. Read/write. See Figure 10-8 …\nLVT Timer register. Read/write. See Figure 10-8 for …\nProcessor Priority Register (PPR). Read-only.\nSpurious Interrupt Vector Register (SVR). Read/write. See …\nCurrent Count register (for Timer). Read-only.\nDivide Configuration Register (DCR; for Timer). …\nInitial Count register (for Timer). Read/write.\nTrigger Mode Register (TMR); bits 31:0. Read-only.\nTMR bits 63:32. Read-only.\nTMR bits 95:64. Read-only.\nTMR bits 127:96. Read-only.\nTMR bits 159:128. Read-only.\nTMR bits 191:160. Read-only.\nTMR bits 223:192. Read-only.\nTMR bits 255:224. Read-only.\nTask Priority Register (TPR). Read/write. Bits 31:8 are …\nLocal APIC Version register. Read-only. Same version used …\nAttach driver to the xAPIC (enables device).\nIs this the bootstrap core?\nDetach driver form the xAPIC (disables device).\nEnd Of Interrupt – Acknowledge interrupt delivery.\nReturns the argument unchanged.\nRead local APIC ID.\nCalls <code>U::from(self)</code>.\nSend a INIT IPI to a core.\nDeassert INIT IPI.\nSend a STARTUP IPI to a core.\nCreate a new xAPIC object for the local CPU.\nSend a generic IPI.\nEnable TSC timer.\nSet TSC deadline value.\nRead APIC version\nProcessor state stored in the EFLAGS register.\nDescription of the data-structures for IA-32 paging mode.\nHelpers to program the task state segment. See Intel 3a, …\nThe EFLAGS register.\nBit 1 is always 1.\nAlignment Check (AC)\nAuxiliary Carry Flag (AF)\nCarry Flag (CF)\nDirection Flag (DF)\nID Flag (ID)\nInterrupt Enable Flag (IF)\nI/O Privilege Level (IOPL) 0\nI/O Privilege Level (IOPL) 1\nI/O Privilege Level (IOPL) 2\nI/O Privilege Level (IOPL) 3\nNested Task (NT)\nOverflow Flag (OF)\nParity Flag (PF)\nResume Flag (RF)\nSign Flag (SF)\nTrap Flag (TF)\nVirtual Interrupt Flag (VIF)\nVirtual Interrupt Pending (VIP)\nVirtual-8086 Mode (VM)\nZero Flag (ZF)\nReturns the set containing all flags.\nReturns the intersection between the two sets of flags.\nDisables all flags disabled in the set.\nReturns the union of the two sets of flags.\nAdds the set of flags.\nReturns the raw value of the flags currently stored.\nReturns the left flags, but with all the right flags …\nToggles the set of flags.\nClears the AC flag bit in EFLAGS register.\nReturns the complement of this set of flags.\nReturns <code>true</code> if all of the flags in <code>other</code> are contained …\nReturns the difference between the flags in <code>self</code> and <code>other</code>.\nReturns an empty set of flags.\nReturns the argument unchanged.\nConvert from underlying bit representation, unless that …\nConvert from underlying bit representation, dropping any …\nConvert from underlying bit representation, preserving all …\nCreates a new Flags with the given I/O privilege level.\nInserts the specified flags in-place.\nReturns the intersection between the flags in <code>self</code> and …\nReturns <code>true</code> if there are flags common to both <code>self</code> and …\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if all flags are currently set.\nReturns <code>true</code> if no flags are currently stored.\nCreates a new Flags entry. Ensures bit 1 is set.\nReturns the complement of this set of flags.\nRemoves the specified flags in-place.\nInserts or removes the specified flags depending on the …\nSets the AC flag bit in EFLAGS register.\nReturns the set difference of the two sets of flags.\nDisables all flags enabled in the set.\nReturns the symmetric difference between the flags in <code>self</code> …\nToggles the specified flags in-place.\nReturns the union of between the flags in <code>self</code> and <code>other</code>.\nAccessed; indicates whether software has accessed the …\nAccessed; indicates whether software has accessed the …\nLog2 of base page size (12 bits).\nSize of a base page (4 KiB)\nSize of a cache-line\nDirty; indicates whether software has written to the …\nDirty; indicates whether software has written to the …\nGlobal; if CR4.PGE = 1, determines whether the translation …\nGlobal; if CR4.PGE = 1, determines whether the translation …\nA wrapper for an IO address (IOVA / DMA Address for …\nSize of a large page (4 MiB)\nA type wrapping a large page with a 4 MiB buffer.\nPresent; must be 1 to map a 4-MByte page.\nPresent; must be 1 to map a 4-KByte page.\nPage tables have 512 = 4096 / 32 entries.\nIf the PAT is supported, indirectly determines the memory …\nIf the PAT is supported, indirectly determines the memory …\nA wrapper for a physical address.\nPage-level cache disable.\nPage-level cache disable.\nA page directory.\nA PD Entry consists of an address and a bunch of flags.\nPD configuration bits description.\nPage size; if set this entry maps a 4-MByte page; …\nA page table.\nA PT Entry consists of an address and a bunch of flags.\nPT Entry bits description.\nPage-level write-through.\nPage-level write-through.\nA type wrapping a base page with a 4 KiB buffer.\nRead/write; if 0, writes may not be allowed to the 4-MByte …\nRead/write; if 0, writes may not be allowed to the 4-KByte …\nUser/supervisor; if 0, user-mode accesses are not allowed …\nUser/supervisor; if 0, user-mode accesses are not allowed …\nA wrapper for a virtual address.\nRetrieves the physical address in this entry.\nRetrieves the physical address in this entry.\nReturn address of nearest 4 KiB page (lower or equal than …\nReturn address of nearest 4 KiB page (lower or equal than …\nReturn address of nearest 4 KiB page (lower or equal than …\nReturn address of nearest 4 MiB page (lower or equal than …\nReturn address of nearest 4 MiB page (lower or equal than …\nReturn address of nearest 4 MiB page (lower or equal than …\nReturn address of nearest 4 KiB page (higher or equal than …\nReturn address of nearest 4 KiB page (higher or equal than …\nReturn address of nearest 4 KiB page (higher or equal than …\nReturn address of nearest 4 MiB page (higher or equal than …\nReturn address of nearest 4 MiB page (higher or equal than …\nReturn address of nearest 4 MiB page (higher or equal than …\nReturns the set containing all flags.\nReturns the set containing all flags.\nConvert to mutable pointer.\nConvert to mutable pointer.\nConvert to pointer.\nConvert to pointer.\nConvert to <code>u32</code>\nConvert to <code>u32</code>\nConvert to <code>u32</code>\nConvert to <code>usize</code>\nConvert to <code>usize</code>\nConvert to <code>usize</code>\nOffset within the 4 KiB page.\nOffset within the 4 KiB page.\nOffset within the 4 KiB page.\nReturns the intersection between the two sets of flags.\nReturns the intersection between the two sets of flags.\nDisables all flags disabled in the set.\nDisables all flags disabled in the set.\nReturns the union of the two sets of flags.\nReturns the union of the two sets of flags.\nAdds the set of flags.\nAdds the set of flags.\nReturns the raw value of the flags currently stored.\nReturns the raw value of the flags currently stored.\nReturns the left flags, but with all the right flags …\nReturns the left flags, but with all the right flags …\nToggles the set of flags.\nToggles the set of flags.\nReturns the complement of this set of flags.\nReturns the complement of this set of flags.\nReturns <code>true</code> if all of the flags in <code>other</code> are contained …\nReturns <code>true</code> if all of the flags in <code>other</code> are contained …\nReturns the difference between the flags in <code>self</code> and <code>other</code>.\nReturns the difference between the flags in <code>self</code> and <code>other</code>.\nReturns an empty set of flags.\nReturns an empty set of flags.\nReturns the flags corresponding to this entry.\nReturns the flags corresponding to this entry.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert from underlying bit representation, unless that …\nConvert from underlying bit representation, unless that …\nConvert from underlying bit representation, dropping any …\nConvert from underlying bit representation, dropping any …\nConvert from underlying bit representation, preserving all …\nConvert from underlying bit representation, preserving all …\nConvert from <code>u32</code>\nConvert from <code>usize</code>\nInserts the specified flags in-place.\nInserts the specified flags in-place.\nReturns the intersection between the flags in <code>self</code> and …\nReturns the intersection between the flags in <code>self</code> and …\nReturns <code>true</code> if there are flags common to both <code>self</code> and …\nReturns <code>true</code> if there are flags common to both <code>self</code> and …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAccessed; indicates whether software has accessed the …\nAccessed; indicates whether software has accessed the …\nIs this address aligned to <code>align</code>?\nIs this address aligned to <code>align</code>?\nIs this address aligned to <code>align</code>?\nReturns <code>true</code> if all flags are currently set.\nReturns <code>true</code> if all flags are currently set.\nIs this address aligned to a 4 KiB page?\nIs this address aligned to a 4 KiB page?\nIs this address aligned to a 4 KiB page?\nDirty; indicates whether software has written to the …\nDirty; indicates whether software has written to the …\nReturns <code>true</code> if no flags are currently stored.\nReturns <code>true</code> if no flags are currently stored.\nGlobal; if CR4.PGE = 1, determines whether the translation …\nGlobal; if CR4.PGE = 1, determines whether the translation …\nIs this address aligned to a 4 MiB page?\nIs this address aligned to a 4 MiB page?\nIs this address aligned to a 4 MiB page?\nPage size; if set this entry maps a 4-MByte page; …\nPage-level cache disable.\nPage-level cache disable.\nPage-level write-through.\nPage-level write-through.\nIf the PAT is supported, indirectly determines the memory …\nIf the PAT is supported, indirectly determines the memory …\nPresent; must be 1 to map a 4-MByte page.\nPresent; must be 1 to map a 4-KByte page.\nUser/supervisor; if 0, user-mode accesses are not allowed …\nUser/supervisor; if 0, user-mode accesses are not allowed …\nRead/write; if 0, writes may not be allowed to the 4-MByte …\nRead/write; if 0, writes may not be allowed to the 4-KByte …\nIs zero?\nIs zero?\nIs zero?\nOffset within the 4 MiB page.\nOffset within the 4 MiB page.\nOffset within the 4 MiB page.\nCreates a new PDEntry.\nCreates a new PTEntry.\nReturns the complement of this set of flags.\nReturns the complement of this set of flags.\nGiven virtual address calculate corresponding entry in PD.\nGiven virtual address calculate corresponding entry in PT.\nRemoves the specified flags in-place.\nRemoves the specified flags in-place.\nInserts or removes the specified flags depending on the …\nInserts or removes the specified flags depending on the …\nReturns the set difference of the two sets of flags.\nReturns the set difference of the two sets of flags.\nDisables all flags enabled in the set.\nDisables all flags enabled in the set.\nReturns the symmetric difference between the flags in <code>self</code> …\nReturns the symmetric difference between the flags in <code>self</code> …\nToggles the specified flags in-place.\nToggles the specified flags in-place.\nReturns the union of between the flags in <code>self</code> and <code>other</code>.\nReturns the union of between the flags in <code>self</code> and <code>other</code>.\nPhysical Address zero.\nIO Address zero.\nVirtual Address zero.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nDescription of the data-structures for IA-32e paging mode.\nProcessor state stored in the RFLAGS register.\nProgram x86 enclaves.\nInvokes an OS system-call handler at privilege level 0.\nHelpers to program the task state segment. See Intel 3a, …\nVirtualize processor hardware for multiple software …\nAccessed; indicates whether this entry has been used for …\nAccessed; indicates whether this entry has been used for …\nAccessed; if PS set indicates whether software has …\nAccessed; if PS set indicates whether software has …\nAccessed; indicates whether software has accessed the …\nLog2 of base page size (12 bits).\nSize of a base page (4 KiB)\nSize of a cache-line\nDirty; if PS indicates whether software has written to the …\nDirty; if PS indicates whether software has written to the …\nDirty; indicates whether software has written to the …\nGlobal; if PS &amp;&amp; CR4.PGE = 1, determines whether the …\nGlobal; if PS &amp;&amp; CR4.PGE = 1, determines whether the …\nGlobal; if CR4.PGE = 1, determines whether the translation …\nSize of a huge page (1 GiB)\nA type wrapping a huge page with a 1 GiB buffer.\nA wrapper for an IO address (IOVA / DMA Address for …\nSize of a large page (2 MiB)\nA type wrapping a large page with a 2 MiB buffer.\nMAXPHYADDR, which is at most 52; (use CPUID for finding …\nMaximum virtual address.\nMaximum supported bits for virtual addresses (with 5-level …\nPresent; must be 1 to reference a page-directory-pointer …\nPresent; must be 1 to reference a PML5 entry\nPresent; must be 1 to map a 1-GByte page or reference a …\nPresent; must be 1 to map a 2-MByte page or reference a …\nPresent; must be 1 to map a 4-KByte page.\nPage tables have 512 = 4096 / 64 entries.\nIndirectly determines the memory type used to access the …\nIndirectly determines the memory type used to access the …\nA wrapper for a physical address.\nPage-level cache disable; indirectly determines the memory …\nPage-level cache disable; indirectly determines the memory …\nPage-level cache disable.\nPage-level cache disable.\nPage-level cache disable.\nA page directory.\nA PD Entry consists of an address and a bunch of flags.\nPD configuration bits description.\nA page directory pointer table.\nA PDPT Entry consists of an address and a bunch of flags.\nPDPT configuration bit description.\nA PML4 table.\nA PML4 Entry consists of an address and a bunch of flags.\nPML4 configuration bit description.\nSize of a region covered by a PML4 Entry (512 GiB)\nA PML5 table\nA PML5 Entry consists of an address and a bunch of flags.\nPML5 configuration bit description.\nPage size; if set this entry maps a 1-GByte page; …\nPage size; if set this entry maps a 2-MByte page; …\nA page table.\nA PT Entry consists of an address and a bunch of flags.\nPT Entry bits description.\nPage-level write-through; indirectly determines the memory …\nPage-level write-through; indirectly determines the memory …\nPage-level write-through.\nPage-level write-through.\nPage-level write-through.\nA type wrapping a base page with a 4 KiB buffer.\nRead/write; if 0, writes may not be allowed to the …\nRead/write; if 0, writes may not be allowed to the …\nRead/write; if 0, writes may not be allowed to the 1-GByte …\nRead/write; if 0, writes may not be allowed to the 2-MByte …\nRead/write; if 0, writes may not be allowed to the 4-KByte …\nUser/supervisor; if 0, user-mode accesses are not allowed …\nUser/supervisor; if 0, user-mode accesses are not allowed …\nUser/supervisor; user-mode accesses are not allowed to the …\nUser/supervisor; user-mode accesses are not allowed to the …\nUser/supervisor; user-mode accesses are not allowed to the …\nUser defined flag – ignored by hardware (bit 10)\nUser defined flag – ignored by hardware (bit 10)\nUser defined flag – ignored by hardware (bit 10)\nUser defined flag – ignored by hardware (bit 10)\nUser defined flag – ignored by hardware (bit 10)\nUser defined flag – ignored by hardware (bit 11)\nUser defined flag – ignored by hardware (bit 11)\nUser defined flag – ignored by hardware (bit 11)\nUser defined flag – ignored by hardware (bit 11)\nUser defined flag – ignored by hardware (bit 11)\nUser defined flag – ignored by hardware (bit 9)\nUser defined flag – ignored by hardware (bit 9)\nUser defined flag – ignored by hardware (bit 9)\nUser defined flag – ignored by hardware (bit 9)\nUser defined flag – ignored by hardware (bit 9)\nA wrapper for a virtual address.\nIf IA32_EFER.NXE = 1, execute-disable If 1, instruction …\nIf IA32_EFER.NXE = 1, execute-disable If 1, instruction …\nIf IA32_EFER.NXE = 1, execute-disable If 1, instruction …\nIf IA32_EFER.NXE = 1, execute-disable If 1, instruction …\nIf IA32_EFER.NXE = 1, execute-disable If 1, instruction …\nRetrieves the physical address in this entry.\nRetrieves the physical address in this entry.\nRetrieves the physical address in this entry.\nRetrieves the physical address in this entry.\nRetrieves the physical address in this entry.\nReturn address of nearest 4 KiB page (lower or equal than …\nReturn address of nearest 4 KiB page (lower or equal than …\nReturn address of nearest 4 KiB page (lower or equal than …\nReturn address of nearest 1 GiB page (lower or equal than …\nReturn address of nearest 1 GiB page (lower or equal than …\nReturn address of nearest 1 GiB page (lower or equal than …\nReturn address of nearest 2 MiB page (lower or equal than …\nReturn address of nearest 2 MiB page (lower or equal than …\nReturn address of nearest 2 MiB page (lower or equal than …\nReturn address of nearest 4 KiB page (higher or equal than …\nReturn address of nearest 4 KiB page (higher or equal than …\nReturn address of nearest 4 KiB page (higher or equal than …\nReturn address of nearest 1 GiB page (higher or equal than …\nReturn address of nearest 1 GiB page (higher or equal than …\nReturn address of nearest 1 GiB page (higher or equal than …\nReturn address of nearest 2 MiB page (higher or equal than …\nReturn address of nearest 2 MiB page (higher or equal than …\nReturn address of nearest 2 MiB page (higher or equal than …\nReturns the set containing all flags.\nReturns the set containing all flags.\nReturns the set containing all flags.\nReturns the set containing all flags.\nReturns the set containing all flags.\nConvert to mutable pointer.\nConvert to pointer.\nConvert to <code>u64</code>\nConvert to <code>u64</code>\nConvert to <code>u64</code>\nConvert to <code>usize</code>\nConvert to <code>usize</code>\nConvert to <code>usize</code>\nOffset within the 4 KiB page.\nOffset within the 4 KiB page.\nOffset within the 4 KiB page.\nReturns the intersection between the two sets of flags.\nReturns the intersection between the two sets of flags.\nReturns the intersection between the two sets of flags.\nReturns the intersection between the two sets of flags.\nReturns the intersection between the two sets of flags.\nDisables all flags disabled in the set.\nDisables all flags disabled in the set.\nDisables all flags disabled in the set.\nDisables all flags disabled in the set.\nDisables all flags disabled in the set.\nReturns the union of the two sets of flags.\nReturns the union of the two sets of flags.\nReturns the union of the two sets of flags.\nReturns the union of the two sets of flags.\nReturns the union of the two sets of flags.\nAdds the set of flags.\nAdds the set of flags.\nAdds the set of flags.\nAdds the set of flags.\nAdds the set of flags.\nReturns the raw value of the flags currently stored.\nReturns the raw value of the flags currently stored.\nReturns the raw value of the flags currently stored.\nReturns the raw value of the flags currently stored.\nReturns the raw value of the flags currently stored.\nReturns the left flags, but with all the right flags …\nReturns the left flags, but with all the right flags …\nReturns the left flags, but with all the right flags …\nReturns the left flags, but with all the right flags …\nReturns the left flags, but with all the right flags …\nToggles the set of flags.\nToggles the set of flags.\nToggles the set of flags.\nToggles the set of flags.\nToggles the set of flags.\nReturns the complement of this set of flags.\nReturns the complement of this set of flags.\nReturns the complement of this set of flags.\nReturns the complement of this set of flags.\nReturns the complement of this set of flags.\nReturns <code>true</code> if all of the flags in <code>other</code> are contained …\nReturns <code>true</code> if all of the flags in <code>other</code> are contained …\nReturns <code>true</code> if all of the flags in <code>other</code> are contained …\nReturns <code>true</code> if all of the flags in <code>other</code> are contained …\nReturns <code>true</code> if all of the flags in <code>other</code> are contained …\nReturns the difference between the flags in <code>self</code> and <code>other</code>.\nReturns the difference between the flags in <code>self</code> and <code>other</code>.\nReturns the difference between the flags in <code>self</code> and <code>other</code>.\nReturns the difference between the flags in <code>self</code> and <code>other</code>.\nReturns the difference between the flags in <code>self</code> and <code>other</code>.\nReturns an empty set of flags.\nReturns an empty set of flags.\nReturns an empty set of flags.\nReturns an empty set of flags.\nReturns an empty set of flags.\nReturns the flags corresponding to this entry.\nReturns the flags corresponding to this entry.\nReturns the flags corresponding to this entry.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert from underlying bit representation, unless that …\nConvert from underlying bit representation, unless that …\nConvert from underlying bit representation, unless that …\nConvert from underlying bit representation, unless that …\nConvert from underlying bit representation, unless that …\nConvert from underlying bit representation, dropping any …\nConvert from underlying bit representation, dropping any …\nConvert from underlying bit representation, dropping any …\nConvert from underlying bit representation, dropping any …\nConvert from underlying bit representation, dropping any …\nConvert from underlying bit representation, preserving all …\nConvert from underlying bit representation, preserving all …\nConvert from underlying bit representation, preserving all …\nConvert from underlying bit representation, preserving all …\nConvert from underlying bit representation, preserving all …\nConvert from <code>u64</code>\nConvert from <code>usize</code>\nOffset within the 1 GiB page.\nOffset within the 1 GiB page.\nOffset within the 1 GiB page.\nInserts the specified flags in-place.\nInserts the specified flags in-place.\nInserts the specified flags in-place.\nInserts the specified flags in-place.\nInserts the specified flags in-place.\nReturns the intersection between the flags in <code>self</code> and …\nReturns the intersection between the flags in <code>self</code> and …\nReturns the intersection between the flags in <code>self</code> and …\nReturns the intersection between the flags in <code>self</code> and …\nReturns the intersection between the flags in <code>self</code> and …\nReturns <code>true</code> if there are flags common to both <code>self</code> and …\nReturns <code>true</code> if there are flags common to both <code>self</code> and …\nReturns <code>true</code> if there are flags common to both <code>self</code> and …\nReturns <code>true</code> if there are flags common to both <code>self</code> and …\nReturns <code>true</code> if there are flags common to both <code>self</code> and …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAccessed; indicates whether this entry has been used for …\nAccessed; indicates whether this entry has been used for …\nAccessed; indicates whether this entry has been used for …\nAccessed; if PS set indicates whether software has …\nAccessed; if PS set indicates whether software has …\nIs this address aligned to <code>align</code>?\nIs this address aligned to <code>align</code>?\nIs this address aligned to <code>align</code>?\nReturns <code>true</code> if all flags are currently set.\nReturns <code>true</code> if all flags are currently set.\nReturns <code>true</code> if all flags are currently set.\nReturns <code>true</code> if all flags are currently set.\nReturns <code>true</code> if all flags are currently set.\nIs this address aligned to a 4 KiB page?\nIs this address aligned to a 4 KiB page?\nIs this address aligned to a 4 KiB page?\nDirty; if PS set indicates whether software has written to …\nDirty; if PD_PS set indicates whether software has written …\nReturns <code>true</code> if no flags are currently stored.\nReturns <code>true</code> if no flags are currently stored.\nReturns <code>true</code> if no flags are currently stored.\nReturns <code>true</code> if no flags are currently stored.\nReturns <code>true</code> if no flags are currently stored.\nGlobal; if PS &amp;&amp; CR4.PGE = 1, determines whether the …\nGlobal; if PS &amp;&amp; CR4.PGE = 1, determines whether the …\nIs this address aligned to a 1 GiB page?\nIs this address aligned to a 1 GiB page?\nIs this address aligned to a 1 GiB page?\nIf IA32_EFER.NXE = 1, execute-disable. If 1, instruction …\nIf IA32_EFER.NXE = 1, execute-disable. If 1, instruction …\nIf IA32_EFER.NXE = 1, execute-disable. If 1, instruction …\nIf IA32_EFER.NXE = 1, execute-disable. If 1, instruction …\nIf IA32_EFER.NXE = 1, execute-disable. If 1, instruction …\nIs this address aligned to a 2 MiB page?\nIs this address aligned to a 2 MiB page?\nIs this address aligned to a 2 MiB page?\nPage size; if set this entry maps a 1-GByte page; …\nPage size; if set this entry maps a 2-MByte page; …\nPage-level cache disable; indirectly determines the memory …\nPage-level cache disable; indirectly determines the memory …\nPage-level cache disable.\nPage-level cache disable.\nPage-level cache disable.\nPage-level write-through; indirectly determines the memory …\nPage-level write-through; indirectly determines the memory …\nPage-level write-through.\nPage-level write-through.\nPage-level write-through.\nIndirectly determines the memory type used to access the …\nIndirectly determines the memory type used to access the …\nIs page present?\nIs page present?\nIs page present?\nPresent; must be 1 to map a 2-MByte page or reference a …\nPresent; must be 1 to map a 4-KByte page or reference a …\nUser/supervisor; if 0, user-mode accesses are not allowed …\nUser/supervisor; if 0, user-mode accesses are not allowed …\nUser/supervisor; user-mode accesses are not allowed to the …\nUser/supervisor; user-mode accesses are not allowed to the …\nUser/supervisor; user-mode accesses are not allowed to the …\nRead/write; if 0, writes may not be allowed to the …\nRead/write; if 0, writes may not be allowed to the …\nRead/write; if 0, writes may not be allowed to the 1-GByte …\nRead/write; if 0, writes may not be allowed to the 2-MByte …\nRead/write; if 0, writes may not be allowed to the 4-KByte …\nIs zero?\nIs zero?\nIs zero?\nOffset within the 2 MiB page.\nOffset within the 2 MiB page.\nOffset within the 2 MiB page.\nCreates a new PML4Entry.\nCreates a new PML5Entry.\nCreates a new PDPTEntry.\nCreates a new PDEntry.\nCreates a new PTEntry.\nReturns the complement of this set of flags.\nReturns the complement of this set of flags.\nReturns the complement of this set of flags.\nReturns the complement of this set of flags.\nReturns the complement of this set of flags.\nGiven virtual address calculate corresponding entry in PD.\nGiven virtual address calculate corresponding entry in …\nGiven virtual address calculate corresponding entry in …\nGiven virtual address calculate corresponding entry in …\nGiven virtual address calculate corresponding entry in PT.\nRemoves the specified flags in-place.\nRemoves the specified flags in-place.\nRemoves the specified flags in-place.\nRemoves the specified flags in-place.\nRemoves the specified flags in-place.\nInserts or removes the specified flags depending on the …\nInserts or removes the specified flags depending on the …\nInserts or removes the specified flags depending on the …\nInserts or removes the specified flags depending on the …\nInserts or removes the specified flags depending on the …\nSplit <code>PAddr</code> into lower and higher 32-bits.\nSplit <code>IOAddr</code> into lower and higher 32-bits.\nReturns the set difference of the two sets of flags.\nReturns the set difference of the two sets of flags.\nReturns the set difference of the two sets of flags.\nReturns the set difference of the two sets of flags.\nReturns the set difference of the two sets of flags.\nDisables all flags enabled in the set.\nDisables all flags enabled in the set.\nDisables all flags enabled in the set.\nDisables all flags enabled in the set.\nDisables all flags enabled in the set.\nReturns the symmetric difference between the flags in <code>self</code> …\nReturns the symmetric difference between the flags in <code>self</code> …\nReturns the symmetric difference between the flags in <code>self</code> …\nReturns the symmetric difference between the flags in <code>self</code> …\nReturns the symmetric difference between the flags in <code>self</code> …\nToggles the specified flags in-place.\nToggles the specified flags in-place.\nToggles the specified flags in-place.\nToggles the specified flags in-place.\nToggles the specified flags in-place.\nReturns the union of between the flags in <code>self</code> and <code>other</code>.\nReturns the union of between the flags in <code>self</code> and <code>other</code>.\nReturns the union of between the flags in <code>self</code> and <code>other</code>.\nReturns the union of between the flags in <code>self</code> and <code>other</code>.\nReturns the union of between the flags in <code>self</code> and <code>other</code>.\nPhysical Address zero.\nIO Address zero.\nVirtual Address zero.\nRead the RBP register (base pointer register).\nRead the RIP register (instruction pointer).\nRead the RSP register (stack pointer register).\nBit 1 is always 1.\nAlignment Check (AC)\nAuxiliary Carry Flag (AF)\nCarry Flag (CF)\nDirection Flag (DF)\nID Flag (ID)\nInterrupt Enable Flag (IF)\nI/O Privilege Level (IOPL) 0\nI/O Privilege Level (IOPL) 1\nI/O Privilege Level (IOPL) 2\nI/O Privilege Level (IOPL) 3\nNested Task (NT)\nOverflow Flag (OF)\nParity Flag (PF)\nResume Flag (RF)\nSign Flag (SF)\nTrap Flag (TF)\nVirtual Interrupt Flag (VIF)\nVirtual Interrupt Pending (VIP)\nVirtual-8086 Mode (VM)\nZero Flag (ZF)\nThe RFLAGS register. This is duplicated code from bits32 …\nReturns the set containing all flags.\nReturns the intersection between the two sets of flags.\nDisables all flags disabled in the set.\nReturns the union of the two sets of flags.\nAdds the set of flags.\nReturns the raw value of the flags currently stored.\nReturns the left flags, but with all the right flags …\nToggles the set of flags.\nReturns the complement of this set of flags.\nReturns <code>true</code> if all of the flags in <code>other</code> are contained …\nReturns the difference between the flags in <code>self</code> and <code>other</code>.\nReturns an empty set of flags.\nReturns the argument unchanged.\nConvert from underlying bit representation, unless that …\nConvert from underlying bit representation, dropping any …\nConvert from underlying bit representation, preserving all …\nCreates a new Flags with the given I/O privilege level.\nInserts the specified flags in-place.\nReturns the intersection between the flags in <code>self</code> and …\nReturns <code>true</code> if there are flags common to both <code>self</code> and …\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if all flags are currently set.\nReturns <code>true</code> if no flags are currently stored.\nCreates a new Flags entry. Ensures bit 1 is set.\nReturns the complement of this set of flags.\nRemoves the specified flags in-place.\nInserts or removes the specified flags depending on the …\nReturns the set difference of the two sets of flags.\nDisables all flags enabled in the set.\nReturns the symmetric difference between the flags in <code>self</code> …\nToggles the specified flags in-place.\nReturns the union of between the flags in <code>self</code> and <code>other</code>.\nEntry for IDT, GDT or LDT.\nReturns the argument unchanged.\n“Dereferences” the fs register at <code>offset</code>.\n“Dereferences” the gs register at <code>offset</code>.\nCalls <code>U::from(self)</code>.\nReload code segment register.\nRead FS Segment Base\nRead GS Segment Base\nCreate a new segment, TSS or LDT descriptor by setting the …\nSets the interrupt stack table index. The 3-bit IST index …\nCreates a new descriptor with selector and offset (for IDT …\nSwap the GS register.\nWrite FS Segment Base\nWrite GS Segment Base\nCreate an SECS page in the Enclave Page Cache\nAdd a Page to an Uninitialized Enclave.\nAdd a Page to an Initialized Enclave.\nMark a page in EPC as Blocked.\nRead From a Debug Enclave.\nWrite to a Debug Enclave.\nExtend Uninitialized Enclave Measurement by 256 Bytes\nInitialize an Enclave for Execution\nLoads and verifies an EPC page and marks the page as …\nLoads, verifies an EPC page and marks the page as …\nRestrict the Permissions of an EPC Page.\nChange the Type of an EPC Page.\nAdd Version Array.\nRemove a page from the EPC.\nActivates EBLOCK Checks.\nInvalidate an EPC Page and Write out to Main Memory.\nAccept Changes to an EPC Page.\nInitialize a Pending Page.\nEnters an Enclave.\nExits an Enclave.\nRetrieves a Cryptographic Key.\nExtend an EPC Page Permissions.\nCreate a Cryptographic Report of the Enclave.\nRe-Enters an Enclave.\nInvoke a syscall.\nInvoke a syscall.\nInvoke a syscall.\nInvoke a syscall.\nInvoke a syscall.\nInvoke a syscall.\nInvoke a syscall.\nAlthough hardware task-switching is not supported in …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe 16-bit offset to the I/O permission bit map from the …\nThe full 64-bit canonical forms of the interrupt stack …\nCreates a new empty TSS.\nThe full 64-bit canonical forms of the stack pointers …\nSets the stack pointer (<code>stack_ptr</code>) to be used when an …\nSets the stack pointer (<code>stack_ptr</code>) to be used for when an …\nClear VMCS.\nLaunch virtual machine.\nLoad current VMCS pointer.\nReturn current VMCS pointer.\nRead a specified field from a VMCS.\nResume virtual machine.\nWrite to a specified field in a VMCS.\nDisable VMX operation.\nEnable VMX operation.\nIf set, enables debug register based breaks on I/O space …\nEnables the instructions RDFSBASE, RDGSBASE, WRFSBASE, and …\nEnable shared (PDE or PTE) address translation between …\nEnables 5-Level Paging.\nEnable machine check interrupts.\nEnable XSAVE and Processor Extended States.\nEnable: Physical Address Extension (allows to address …\nEnables process-context identifiers (PCIDs).\nEnable Performance-Monitoring Counters\nEnables use of Protection Keys (MPK).\nEnable Page Size Extensions (allows for pages larger than …\nEnable Supervisor Mode Access Prevention.\nEnable Supervisor Mode Execution Protection.\nEnables Safer Mode Extensions (Trusted Execution …\nEnables Streaming SIMD Extensions (SSE) instructions and …\nEnable User-Mode Instruction Prevention (the SGDT, SIDT, …\nIf set, enables support for the virtual interrupt flag …\nEnables Virtual Machine Extensions.\nIf set, disables ability to take time-stamps.\nEnables unmasked SSE exceptions.\nIf set, enables support for the virtual interrupt flag …\nReturns the set containing all flags.\nReturns the set containing all flags.\nReturns the set containing all flags.\nReturns the intersection between the two sets of flags.\nReturns the intersection between the two sets of flags.\nReturns the intersection between the two sets of flags.\nDisables all flags disabled in the set.\nDisables all flags disabled in the set.\nDisables all flags disabled in the set.\nReturns the union of the two sets of flags.\nReturns the union of the two sets of flags.\nReturns the union of the two sets of flags.\nAdds the set of flags.\nAdds the set of flags.\nAdds the set of flags.\nReturns the raw value of the flags currently stored.\nReturns the raw value of the flags currently stored.\nReturns the raw value of the flags currently stored.\nReturns the left flags, but with all the right flags …\nReturns the left flags, but with all the right flags …\nReturns the left flags, but with all the right flags …\nToggles the set of flags.\nToggles the set of flags.\nToggles the set of flags.\nReturns the complement of this set of flags.\nReturns the complement of this set of flags.\nReturns the complement of this set of flags.\nReturns <code>true</code> if all of the flags in <code>other</code> are contained …\nReturns <code>true</code> if all of the flags in <code>other</code> are contained …\nReturns <code>true</code> if all of the flags in <code>other</code> are contained …\nRead cr0\nWrite cr0.\nContains page-fault linear address.\nWrite cr2, for instance to reset cr2\nContains page-table root pointer.\nSwitch page-table PML4 pointer.\nContains various flags to control operations in protected …\nWrite cr4.\nReturns the difference between the flags in <code>self</code> and <code>other</code>.\nReturns the difference between the flags in <code>self</code> and <code>other</code>.\nReturns the difference between the flags in <code>self</code> and <code>other</code>.\nReturns an empty set of flags.\nReturns an empty set of flags.\nReturns an empty set of flags.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert from underlying bit representation, unless that …\nConvert from underlying bit representation, unless that …\nConvert from underlying bit representation, unless that …\nConvert from underlying bit representation, dropping any …\nConvert from underlying bit representation, dropping any …\nConvert from underlying bit representation, dropping any …\nConvert from underlying bit representation, preserving all …\nConvert from underlying bit representation, preserving all …\nConvert from underlying bit representation, preserving all …\nInserts the specified flags in-place.\nInserts the specified flags in-place.\nInserts the specified flags in-place.\nReturns the intersection between the flags in <code>self</code> and …\nReturns the intersection between the flags in <code>self</code> and …\nReturns the intersection between the flags in <code>self</code> and …\nReturns <code>true</code> if there are flags common to both <code>self</code> and …\nReturns <code>true</code> if there are flags common to both <code>self</code> and …\nReturns <code>true</code> if there are flags common to both <code>self</code> and …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if all flags are currently set.\nReturns <code>true</code> if all flags are currently set.\nReturns <code>true</code> if all flags are currently set.\nReturns <code>true</code> if no flags are currently stored.\nReturns <code>true</code> if no flags are currently stored.\nReturns <code>true</code> if no flags are currently stored.\nReturns the complement of this set of flags.\nReturns the complement of this set of flags.\nReturns the complement of this set of flags.\nRemoves the specified flags in-place.\nRemoves the specified flags in-place.\nRemoves the specified flags in-place.\nInserts or removes the specified flags depending on the …\nInserts or removes the specified flags depending on the …\nInserts or removes the specified flags depending on the …\nReturns the set difference of the two sets of flags.\nReturns the set difference of the two sets of flags.\nReturns the set difference of the two sets of flags.\nDisables all flags enabled in the set.\nDisables all flags enabled in the set.\nDisables all flags enabled in the set.\nReturns the symmetric difference between the flags in <code>self</code> …\nReturns the symmetric difference between the flags in <code>self</code> …\nReturns the symmetric difference between the flags in <code>self</code> …\nToggles the specified flags in-place.\nToggles the specified flags in-place.\nToggles the specified flags in-place.\nReturns the union of between the flags in <code>self</code> and <code>other</code>.\nReturns the union of between the flags in <code>self</code> and <code>other</code>.\nReturns the union of between the flags in <code>self</code> and <code>other</code>.\nRead Extended Control Register XCR0. Only supported if …\nWrite to Extended Control Register XCR0. Only supported if …\nProcessor Power Management and RAS Capabilities …\nInfo about cache Associativity.\nThis table is taken from Intel manual (Section CPUID …\nDescribes any kind of cache (TLB, Data and Instruction …\nIterates over cache information (LEAF=0x02).\nWhat type of cache are we dealing with?\nInformation about an individual cache in the hierarchy.\nIterator over caches (LEAF=0x04).\nInfo about a what a given cache caches (instructions, …\nThe main type used to query information about the CPU we’…\nLow-level data-structure to store result of cpuid …\nDeterministic Address Translation Structure\nDeterministic Address Translation Structure Iterator …\nDeterministic Address Translation cache type (EDX bits 04 …\nData cache\nDirect cache access info (LEAF=0x09).\nEBX:EAX and EDX:ECX provide information on the Enclave …\nStructured Extended Feature Identifiers (LEAF=0x07).\nExtended Processor and Processor Feature Identifiers …\nWhere the extended register state is stored.\nWhat kidn of extended register state this is.\nExtendedState subleaf structure for things that need to be …\nInformation for saving/restoring extended register state …\nYields ExtendedState structs.\nInformation about topology (LEAF=0x0B).\nGives information about the current level in the topology.\nProcessor and Processor Feature Identifiers (LEAF=0x01).\nIdentifies the different Hypervisor products.\nInformation about Hypervisor (LEAF=0x4000_0001)\nInstruction cache\nL1 Cache and TLB Information (LEAF=0x8000_0005).\nL2/L3 Cache and TLB Information (LEAF=0x8000_0006).\nL2 Cache Allocation Technology Enumeration Sub-leaf …\nL3 Cache Allocation Technology Enumeration Sub-leaf …\nInformation about L3 cache monitoring.\nMemory Bandwidth Allocation Enumeration Sub-leaf …\nEncrypted Memory Capabilities (LEAF=0x8000_001F).\nInformation about how monitor/mwait works on this CPU …\nNull - No more caches\nNull (indicates this sub-leaf is not valid).\nInfo about performance monitoring – how many counters …\nPerformance Optimization Identifier (LEAF=0x8000_001A).\nProcessor name (LEAF=0x8000_0002..=0x8000_0004).\nProcessor Capacity Parameters and Extended Feature …\nProcessor Frequency Information (LEAF=0x16).\nProcessor Serial Number (LEAF=0x3).\nProcessor Topology Information (LEAF=0x8000_001E).\nIntel Processor Trace Information (LEAF=0x14).\nQEMU is the hypervisor identity when QEMU is used without …\nQuality of service enforcement information (LEAF=0x10).\nIntel Resource Director Technology RDT (LEAF=0x0F).\n4-31 = Reserved\nHyper-thread (Simultaneous multithreading)\nIntel SGX Capability Enumeration Leaf (LEAF=0x12).\nIntel SGX EPC Enumeration Leaf\nIterator over the SGX sub-leafs (ECX &gt;= 2).\nIterator for SoC vendor attributes.\nA vendor brand string as queried from the cpuid leaf.\nSoC vendor specific information (LEAF=0x17).\nInformation about the SVM features that the processory …\nQuery information about thermal and power management …\nTLB 1-GiB Pages Information (LEAF=0x8000_0019).\nWhat type of core we have at this level in the topology …\nTime Stamp Counter/Core Crystal Clock Information …\nData and Instruction cache\nSome unified TLBs will allow a single TLB entry to satisfy …\nVendor Info String (LEAF=0x0)\n(Virtual) Bus (local apic timer) frequency in kHz.\nAPIC ID size.\nReturn the processor brand string as a rust string.\nReturn vendor identification as human readable string.\nReturn the SocVendorBrand as a string.\nWays of associativity (Bits 31-22)\nVersion Information: Family\nVersion Information: Model\nReturns brand ID on AMD.\nBrand Index\nBus (Reference) Frequency (in MHz).\nC-bit location in page table entry\nTranslation cache level (starts at 1)\nTranslation cache type field.\nCache Type\nLength of the capacity bit mask.\nLength of the capacity bit mask.\nCLFLUSH line size (Value ∗ 8 = cache line size in bytes)\nSystem Coherency Line Size (Bits 11-00)\nNumber of configurable Address Ranges for filtering (Bits …\nConversion factor from reported IA32_QM_CTR value to …\nCore ID\nBit width of general-purpose, performance monitoring …\nSpecifies the ratio of the compute unit power accumulator …\nMacro which queries cpuid directly.\nL1 data cache associativity.\nL1 data cache line size in bytes.\nL1 data cache lines per tag.\nL1 data cache size in KB\nAn unsigned integer which is the denominator of the …\nDescription of the cache (from Intel Manual)\nData TLB associativity for 2-MB and 4-MB pages.\nL2 Data TLB associativity for 2-MB and 4-MB pages.\nData TLB number of entries for 2-MB and 4-MB pages.\nL2 Data TLB number of entries for 2-MB and 4-MB pages.\nData TLB associativity for 4K pages.\nL2 Data TLB associativity for 4K pages.\nData TLB number of entries for 4K pages.\nL2 Data TLB number of entries for 4K pages.\nL1 Data TLB associativity for 1-GB pages.\nL1 Data TLB number of entries for 1-GB pages.\nL2 Data TLB associativity for 1-GB pages.\nL2 Data TLB number of entries for 1-GB pages.\nNumber of Interrupt Thresholds in Digital Thermal Sensor\nReturn value EAX register\nReturn value EBX register\nLength of EBX bit vector to enumerate architectural …\nReturn value ECX register\nReturn value EDX register\nVersion Information: Extended Family\nVersion Information: Extended Model\nExtended Processor Signature.\nEnumeration of Monitor-Mwait extensions (beyond EAX and …\nNumber of fixed-function performance counters (if Version …\nBit width of fixed-function performance counters (if …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nAdvanced Power Management Information (LEAF=0x8000_0007).\nQuery basic information about caches (LEAF=0x02).\nRetrieve more elaborate information about caches …\nValue of bits [31:0] of IA32_PLATFORM_DCA_CAP MSR (address …\nQuery deterministic address translation feature …\nDirect cache access info (LEAF=0x09).\nFind out about more features supported by this CPU …\nExtended Processor and Processor Feature Identifiers …\nInformation for saving/restoring extended register state …\nInformation about topology (LEAF=0x0B).\nExtended information about topology (LEAF=0x1F).\nQuery a set of features that are available on this CPU …\nReturns information provided by the hypervisor, if running …\nL1 Instruction Cache Information (LEAF=0x8000_0005)\nL2/L3 Cache and TLB Information (LEAF=0x8000_0006).\nInformations about memory encryption support …\nInformation about how monitor/mwait works on this CPU …\nInfo about performance monitoring (LEAF=0x0A).\nInformations about performance optimization …\nRetrieve processor brand string (LEAF=0x8000_000{2..4}).\nProcessor Capacity Parameters and Extended Feature …\nProcessor Frequency Information (LEAF=0x16).\nRetrieve serial number of processor (LEAF=0x03).\nInformations about processor topology (LEAF=0x8000_001E)\nIntel Processor Trace Enumeration Information (LEAF=0x14).\nQuality of service enforcement information (LEAF=0x10).\nQuality of service monitoring information (LEAF=0x0F).\nInformation about secure enclave support (LEAF=0x12).\nContains SoC vendor specific information (LEAF=0x17).\nThis function provides information about the SVM features …\nQuery information about thermal and power management …\nTLB 1-GiB Pages Information (LEAF=0x8000_0019)\nTime Stamp Counter/Core Crystal Clock Information …\nReturn information about the vendor (LEAF=0x00).\nGuest Physical Address Bits\nHas 100 MHz multiplier Control?\n1GB page size entries supported by this structure\nIs there support for 1GiB pages.\n2MB page size entries supported by this structure\n3DNow extensions.\n4K page size entries supported by this structure\n4MB page size entries supported by this structure\nCheck support for 64-bit mode.\nSEV guest execution only allowed from a 64-bit host if set.\nThermal Monitor and Software Controlled Clock Facilities. …\nBreakpoint Addressing masking extended to bit 31.\nSupports ADX.\nA value of 1 indicates that the processor supports the …\nLOCK MOV CR0 means MOV CR8. See “MOV(CRn)” in APM3.\nAlternate Injection supported if set.\n3DNow AMD extensions.\nAnyThread deprecation\nAPIC On-Chip. The processor contains an Advanced …\nARAT. APIC-Timer-always-running feature is supported if …\nAVX512VBMI2\nSupport for the AMD advanced virtual interrupt controller …\nA value of 1 indicates the processor supports the AVX …\nAVX2\nAVX512_IFMA\nAVX512BITALG\nAVX512BW\nAVX512CD\nSupports AVX512DQ.\nAVX512ER\nSupports AVX512F.\nAVX512PF\nAVX512VL\nAVX512VNNI\nAVX512VPOPCNTDQ\nBMI1\nBMI2\nSupports CET shadow stack features. Processors that set …\nCLZERO instruction supported if set.\nCLFLUSH Instruction. CLFLUSH Instruction is supported.\nSupports CLFLUSHOPT.\nCLWB\nConditional Move Instructions. The conditional move …\nCheck support legacy cmp.\nCMPXCHG16B Available. A value of 1 indicates that the …\nCMPXCHG8B Instruction. The compare-and-exchange 8 bytes …\nL1 Context ID. A value of 1 indicates the L1 data cache …\nIs Code and Data Prioritization Technology supported?\nComplex Cache Indexing (Bit 2) False: Direct mapped cache. …\nIf true, Indicates support of Configurable PSB and …\nHas Core performance boost?\nCPL Qualified Debug Store. A value of 1 indicates the …\nData access breakpoint extension.\nA value of 1 indicates the processor supports the ability …\nDebugging Extensions. Support for I/O breakpoints, …\nFull debug state swap supported for SEV-ES guests.\nIndicates support for the decode assists if set.\nDebug Store. The processor supports the ability to write …\n64-bit DS Area. A value of 1 indicates the processor …\nDigital temperature sensor is supported if set.\nECMD. Clock modulation duty cycle extension is supported …\nEnhanced Intel SpeedStep® technology. A value of 1 …\nSupports ENCLS instruction leaves ETRACKC, ERDINFO, ELDBC, …\nSupports ENCLV instruction leaves EINCVIRTCHILD, …\nThe processor supports performance-energy bias preference …\nIs there support for execute disable bit.\nExtended APIC space.\nA value of 1 indicates that processor supports 16-bit …\nFXSAVE and FXRSTOR instruction optimizations.\nFDP_EXCPTN_ONLY. x87 FPU Data Pointer updated only on x87 …\nIndicates support for processor feedback interface.\nFlexible HWP is supported if set.\nIndicates that TLB flush events, including CR3 writes and …\nA value of 1 indicates the processor supports FMA …\nFour-operand FMA instruction support.\nThe internal FP/SIMD execution datapath is 128 bits wide …\nThe internal FP/SIMD execution datapath is 256 bits wide …\nFloating Point Unit On-Chip. The processor contains an x87 …\nDeprecates FPU CS and FPU DS values if 1.\nFrequency ID control.\nFSGSBASE. Supports RDFSBASE/RDGSBASE/WRFSBASE/WRGSBASE if …\nFXSAVE and FXRSTOR Instructions. The FXSAVE and FXRSTOR …\nGFNI\nGIF – virtualized global interrupt flag if set.\nGuest Mode Execution Trap supported if set.\nHDC. HDC base registers IA32_PKG_HDC_CTL, IA32_PM_CTL1, …\nHLE\nWhen host <code>CR4.MCE=1</code> and guest <code>CR4.MCE=0</code>, machine check …\nMax APIC IDs reserved field is Valid. A value of 0 for HTT …\nHardware Coordination Feedback Capability\nHardware cache coherency across encryption domains …\nHas Hardware P-state control?\nHas Hardware assert supported?\nHWP. HWP base registers (IA32_PM_ENABLE[bit 0], …\nHWP Activity Window. IA32_HWP_REQUEST[bits 41:32] is …\nHWP Capabilities. Highest Performance change is supported …\nHWP Energy Performance Preference. IA32_HWP_REQUEST[bits …\nFast access mode for the IA32_HWP_REQUEST MSR is supported …\nHWP Notification. IA32_HWP_INTERRUPT MSR is supported if …\nHWP Package Level Request. IA32_HWP_REQUEST_PKG MSR is …\nHWP PECI override is supported if set.\nA value of 1 indicates the indicates the presence of a …\nInstruction based sampling.\nIgnoring Idle Logical Processor HWP request is supported …\nInstruction Retired Counter MSR available if set.\nWBINVD/WBNOINVD are interruptible if set.\nIs Invariant TSC available?\nINVLPGB and TLBSYNC instruction supported if set.\nINVLPGB support for invalidating guest nested translations …\nINVPCID. If 1, supports INVPCID instruction for system …\nIf true, Indicates support of IP Filtering, TraceStop …\nSupports L2 Cache Allocation.\nSupports L3 Cache Allocation.\nSupports L3 Cache Intel RDT Monitoring.\nSupports 57-bit linear addresses and five-level paging if …\nIs LAHF/SAHF available in 64-bit mode?\nIndicates support for LBR Virtualization.\nReports whether the response of the delay values is linear.\nIf true, Generated packets which contain IP payloads have …\nSupports local bandwidth monitoring.\nLightweight profiling support\nIs LZCNT available?\nMachine Check Architecture. A value of 1 indicates the …\nIs MCA overflow recovery available?\nMachine Check Exception. Exception 18 is defined for …\nMCOMMIT instruction supported if set.\nSupports Memory Bandwidth Allocation.\nMisaligned SSE mode. See “Misaligned Access Support …\nIntel MMX Technology. The processor supports the Intel MMX …\nAMD extensions to MMX instructions.\nMONITOR/MWAIT. A value of 1 indicates the processor …\nSupport for MWAITX and MONITORX instructions.\nA value of 1 indicates that the processor supports MOVBE …\nMOVU (Move Unaligned) SSE instructions are efficient more …\nMPX. Supports Intel Memory Protection Extensions if 1.\nModel Specific Registers RDMSR and WRMSR Instructions. The …\nIf true, Indicates support of MTC timing packet and …\nMemory Type Range Registers. MTRRs are supported. The …\nNB performance counter extensions support.\nNested paging supported if set.\nIndicates support for NRIP save on #VMEXIT if set.\nSupports occupancy monitoring.\nOS has set CR4.PKE to enable protection keys (and the …\nIndicates OS-visible workaround support\nA value of 1 indicates that the OS has enabled …\nPhysical Address Extension. Physical addresses greater …\nThe Page Flush MSR is available if set.\nPage Attribute Table. Page Attribute Table is supported. …\nIndicates support for the pause intercept filter if set.\nIndicates support for the PAUSE filter cycle count …\nPending Break Enable. The processor supports the use of …\nProcess-context identifiers. A value of 1 indicates that …\nPCLMULQDQ. A value of 1 indicates the processor supports …\nPerfmon and Debug Capability: A value of 1 indicates the …\nProcessor performance counter extensions support.\nSupport for L3 performance counter extension.\nPerformance time-stamp counter.\nPage Global Bit. The global bit is supported in …\nSupports protection keys for user-mode pages.\nPLN. Power limit notification controls are supported if …\nA value of 1 indicates that the processor supports the …\nSupport of Power Event Trace. Writes can set IA32_RTIT_CTL…\nHas Processor power reporting interface?\nIs PREFETCHW available?\nHas PREFETCHWT1 (Intel® Xeon Phi™ only).\nDisallowing IBS use by the host supported if set.\nSupports Intel Processor Trace.\nPage Size Extension. Large pages of size 4 MByte are …\n36-Bit Page Size Extension. 4-MByte pages addressing …\nProcessor Serial Number. The processor supports the 96-bit …\nPTM. Package thermal management is supported if set.\nIndicates support of PTWRITE. Writes can set IA32_RTIT_CTL…\nRDPID and IA32_TSC_AUX are available.\nRDPRU instruction supported if set.\nA value of 1 indicates that processor supports RDRAND …\nSupports RDSEED.\nSupports Intel Resource Director Technology (RDT) …\nSupports Intel Resource Director Technology (RDT) …\nCheck support for rdtscp instruction.\nSupports Enhanced REP MOVSB/STOSB if 1.\nFP Error Pointers Restored by XRSTOR if set.\nRestricted Injection supported if set.\nHas Read-only effective frequency interface?\nIf true, Indicates that IA32_RTIT_CTL.CR3Filter can be set …\nRTM\nSecure Encrypted Virtualization is supported if set.\nSEV Encrypted State is supported if set.\nSEV Secure Nested Paging supported if set.\nSupports Intel® Software Guard Extensions (Intel® SGX …\nHas SGX1 support.\nHas SGX2 support.\nSupports SGX Launch Configuration.\nSupports SHA Instructions.\nIf true, Indicates support of Single-Range Output scheme.\nSKINIT and STGI are supported.\nSMAP. Supports Supervisor-Mode Access Prevention (and the …\nSecure Memory Encryption is supported if set.\nSMEP. Supports Supervisor-Mode Execution Prevention if 1.\nSafer Mode Extensions. A value of 1 indicates that the …\nSPEC_CTRL virtualization supported if set.\nSelf Snoop. The processor supports the management of …\nSSE. The processor supports the SSE extensions.\nSSE2. The processor supports the SSE2 extensions.\nStreaming SIMD Extensions 3 (SSE3). A value of 1 indicates …\nA value of 1 indicates that the processor supports SSE4.1.\nA value of 1 indicates that the processor supports SSE4.2.\nXTRQ, INSERTQ, MOVNTSS, and MOVNTSD instruction support.\nSVM supervisor shadow stack restrictions if set.\nA value of 1 indicates the presence of the Supplemental …\nHas Software uncorrectable error containment and recovery …\nSecure virtual machine supported.\nIndicates support for SVM-Lock if set.\nAre fast system calls available.\nSYSENTER and SYSEXIT Instructions. The SYSENTER and …\nTrailing bit manipulation instruction support.\nHas THERMTRIP?\nSupport for INVLPGB/TLBSYNC hypervisor enable in VMCB and …\nThermal Monitor. The processor implements the thermal …\nHardware thermal control (HTC)?\nThermal Monitor 2. A value of 1 indicates whether the …\nIndicates the following MSRs are supported: …\nIf true, Tracing can be enabled with IA32_RTIT_CTL.ToPA = …\nIf true, ToPA tables can hold any number of output …\nTopology extensions support.\nSupports total bandwidth monitoring.\nIf true, Indicates support of output to Trace Transport …\nIs Temperature Sensor available?\nTime Stamp Counter. The RDTSC instruction is supported, …\nIA32_TSC_ADJUST MSR is supported if 1.\nA value of 1 indicates that the processors local APIC …\nIndicates support for MSR TSC ratio (MSR <code>0xC000_0104</code>) if …\nIntel Turbo Boost Technology Available (see description of …\nIntel® Turbo Boost Max Technology 3.0 available.\nSupports user-mode instruction prevention if 1.\nEFER.LMSLE is unsupported if set.\nVAES\nIndicates support for VMCB clean bits if set.\nVirtual 8086 Mode Enhancements. Virtual 8086 mode …\nVM Permission Levels supported if set.\nVMSAVE and VMLOAD virtualization supported if set.\nVirtual Machine Extensions. A value of 1 indicates that …\nVoltage ID control.\nVPCLMULQDQ\nVirtual Transparent Encryption supported if set.\nWAITPKG\nWBNOINVD instruction supported if set.\nWatchdog timer support.\nA value of 1 indicates that the processor supports x2APIC …\nSupports XGETBV with ECX = 1 if set.\nExtended operation support.\nA value of 1 indicates that the processor supports the …\nSupports XSAVEC and the compacted form of XRSTOR if set.\nCPU has xsaveopt feature.\nSupports XSAVES/XRSTORS and IA32_XSS if set.\nHighest COS number supported for this Leaf.\nHighest COS number supported for this Leaf.\nHighest COS number supported for this Leaf.\nSupport for HDC in IA32_XSS.\nSupport for PT in IA32_XSS.\nL1 instruction cache associativity.\nL1 instruction cache line size in bytes.\nL1 instruction cache lines per tag.\nL1 instruction cache size in KB\nReturns the identity of the <code>Hypervisor</code>.\nInitial APIC ID\nSupports treating interrupts as break-event for MWAIT, …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMaximum page count for INVLPGB instruction.\nBranch instruction retired event not available if 1.\nBranch mispredict retired event not available if 1.\nLast-level cache reference event not available if 1.\nReturns true when the compacted format of an XSAVE area is …\nCore cycle event not available if 1.\nFully associative structure\nFully Associative cache\nTrue if the bit n (corresponding to the sub-leaf index) is …\nTrue if bit n is supported in XCR0.\nCache Inclusiveness (Bit 1) False: Cache is not inclusive …\nInstruction retired event not available if 1.\nLast-level cache misses event not available if 1.\nReference cycles event not available if 1.\nSelf Initializing cache level (does not need SW …\nWrite-Back Invalidate/Invalidate (Bit 0) False: …\nBit-granular map of isolation/contention of allocation …\nBit-granular map of isolation/contention of allocation …\nIterator over extended state enumeration levels &gt;= 2.\nIterator over SGX sub-leafs.\nInstruction TLB associativity for 2-MB and 4-MB pages.\nL2 Instruction TLB associativity for 2-MB and 4-MB pages.\nInstruction TLB number of entries for 2-MB and 4-MB pages.\nL2 Instruction TLB number of entries for 2-MB and 4-MB …\nInstruction TLB associativity for 4K pages.\nL2 Instruction TLB associativity for 4K pages.\nInstruction TLB number of entries for 4K pages.\nL2 Instruction TLB number of entries for 4K pages.\nL1 Instruction TLB associativity for 1-GB pages.\nL1 Instruction TLB number of entries for 1-GB pages.\nL2 Instruction TLB associativity for 1-GB pages.\nL2 Instruction TLB number of entries for 1-GB pages.\nL2 Cache Allocation Information.\nL2 Associativity field\nL2 Cache Line size in bytes\nL2 cache lines per tag.\nCache size in KB.\nL3 Cache Allocation Information.\nL3 Cache Monitoring.\nL2 Associativity field\nL2 Cache Line size in bytes\nL2 cache lines per tag.\nSpecifies the L3 cache size range\nLargest monitor-line size in bytes (default is processor’…\nCache Level (starts at 1)\nLevel number.\nLinear Address Bits\nThe value of MAWAU used by the BNDLDX and BNDSTX …\nMaximum number of addressable IDs for logical processors …\nMaximum number of addressable IDs for logical processors …\nMaximum number of addressable IDs for processor cores in …\nThe maximum supported enclave size in 64-bit mode is …\nThe maximum supported enclave size in non-64-bit mode is …\nNumber of encrypted guests supported simultaneouslys\nReports the maximum MBA throttling value supported for the …\nMaximum number of addressable IDs for logical processors …\nThe maximum ECX value recognized by RDPRU.\nThe size of the <code>apic_id_size</code> field determines the maximum …\nMaximum range (zero-based) of RMID of L3.\nMemory Bandwidth Allocation Information.\nMinimum ASID value for an SEV enabled, SEV-ES disabled …\nBit vector of supported extended SGX features.\nUses Rust’s <code>cpuid</code> function from the <code>arch</code> module.\nReturn new CpuId struct.\nIterate over all cache information.\nIterate over all cache info subleafs for this CPU.\nIterate over each sub-leaf with an address translation …\nIterate over all SoC vendor specific attributes.\nNode ID\nNodes per processor\nAn unsigned integer which is the nominal frequency of the …\nNumber as retrieved from cpuid\nNumber of physical threads in the processor.\nNumber of general-purpose performance monitoring counter …\nAn unsigned integer which is the numerator of the …\nThe offset in bytes of this extended state components save …\nPartitioning (0: Soft partitioning between the logical …\nPerformance time-stamp counter size (in bits).\nPhysical Address Bits\nPhysical Address bit reduction\nThe physical address of the base of the EPC section\nPhysical Line partitions (Bits 21-12)\nReturns package type on AMD.\nProcessor Base Frequency (in MHz).\nMaximum Frequency (in MHz).\nNumber of logical processors at this level type. The …\nReturns which register this specific extended subleaf …\nSVM revision number.\nMaximum range (zero-based) of RMID within this physical …\nReports the valid bits of SECS.ATTRIBUTES[127:0] that …\nCombination of bits 00-31 and 32-63 of 96 bit processor …\n96 bit processor serial number.\nBits 00-31 of 96 bit processor serial number.\nBits 32-63 of 96 bit processor serial number.\nBits 64-96 of 96 bit processor serial number.\nNumber of Sets.\nNumber of Sets (Bits 31-00)\nNumber of bits to shift right on x2APIC ID to get a unique …\nThe size in bytes (from the offset specified in EBX) of …\nSize of the corresponding EPC section within the Processor …\nSmallest monitor-line size in bytes (default is processor…\nVersion Information: Stepping ID\nNumber of available address space identifiers (ASID).\nNumber of C0 sub C-states supported using MWAIT (Bits 03 - …\nNumber of C1 sub C-states supported using MWAIT (Bits 07 - …\nNumber of C2 sub C-states supported using MWAIT (Bits 11 - …\nNumber of C3 sub C-states supported using MWAIT (Bits 15 - …\nNumber of C4 sub C-states supported using MWAIT (Bits 19 - …\nNumber of C5 sub C-states supported using MWAIT (Bits 23 - …\nNumber of C6 sub C-states supported using MWAIT (Bits 27 - …\nNumber of C7 sub C-states supported using MWAIT (Bits 31 - …\nBitmap of supported Cycle Threshold value encodings (Bits …\nBitmap of supported MTC period encodings (Bit 31:16).\nBitmap of supported Configurable PSB frequency encodings …\nThreads per core\n“TSC frequency” = “core crystal clock frequency” * …\nTSC frequency in kHz.\nCache type\nVersion ID of architectural performance monitoring. (Bits …\nWays of associativity.\nReturn new CpuId struct with custom reader function.\nx2APIC ID\nx2APIC ID the current logical processor. (Bits 31-00)\nSupport for AVX512 OPMASK in XCR0.\nSupport for AVX512 ZMM Hi16 in XCR0.\nSupport for AVX512 ZMM Hi256 XCR0.\nSupport for AVX 256-bit in XCR0.\nSupport for legacy x87 in XCR0.\nSupport for MPX BNDCSR in XCR0.\nSupport for MPX BNDREGS in XCR0.\nSupport for PKRU in XCR0.\nSupport for SSE 128-bit in XCR0.\nMaximum size (bytes, from the beginning of the …\nMaximum size (bytes, from the beginning of the …\nThe size in bytes of the XSAVE area containing all states …\nB0 breakpoint condition detected\nB1 breakpoint condition detected\nB2 breakpoint condition detected\nB3 breakpoint condition detected\nBD debug register access detected\nAn array list of all available breakpoint registers.\nBS single step\nBT task switch\nSpecifies the  breakpoint condition for a corresponding …\nSpecify the size of the memory location at the address …\nSpecifies available hardware breakpoints.\n00 — 1-byte length.\n01 — 2-byte length.\n11 — 4-byte length.\n10 — 8 byte length (or undefined, on older processors).\n11 — Break on data reads or writes but not instruction …\n01 — Break on data writes only.\nDebug register 6 (dr6) flags.\nEmpty Dr7 has bit 10 always set.\nBit that controls debug-register protection.\nBit that controls global exact breakpoints.\n00 — Break on instruction execution only.\n10 — Break on I/O reads or writes.\nBit that controls local exact breakpoints.\nEnables (when set) advanced debugging of RTM transactional …\nBit that controls debugging of RTM transactional regions.\nReturns the set containing all flags.\nReturns the intersection between the two sets of flags.\nDisables all flags disabled in the set.\nReturns the union of the two sets of flags.\nAdds the set of flags.\nReturns the raw value of the flags currently stored.\nReturns the left flags, but with all the right flags …\nToggles the set of flags.\nReturns the complement of this set of flags.\nConfigures the breakpoint by writing <code>dr</code> registers.\nConfigures a breakpoint condition <code>bc</code> and size <code>bs</code> for the …\nReturns <code>true</code> if all of the flags in <code>other</code> are contained …\nReturns the difference between the flags in <code>self</code> and <code>other</code>.\nDisables the breakpoint condition for the associated …\nDisable breakpoint in global mode.\nDisable breakpoint in local mode.\nRead dr{0-3} register based on enum variant.\nRead dr0.\nWrite dr0.\nRead dr1.\nWrite dr1.\nRead dr2.\nWrite dr2.\nRead dr3.\nWrite dr3.\nRead dr6.\nWrite dr6.\nRead dr7.\nWrite dr7.\nReturns an empty set of flags.\nEnables the breakpoint condition for the associated …\nGlobal exact breakpoint enable.\nLocal exact breakpoint enable.\nEnables debug-register protection, which causes a debug …\nEnable the breakpoint in global mode.\nEnable the breakpoint in local mode.\nEnables advanced debugging of RTM transactional regions.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert from underlying bit representation, unless that …\nConvert from underlying bit representation, dropping any …\nConvert from underlying bit representation, preserving all …\nInserts the specified flags in-place.\nReturns the intersection between the flags in <code>self</code> and …\nReturns <code>true</code> if there are flags common to both <code>self</code> and …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if all flags are currently set.\nReturns <code>true</code> if no flags are currently stored.\nReturns the complement of this set of flags.\nRemoves the specified flags in-place.\nInserts or removes the specified flags depending on the …\nReturns the set difference of the two sets of flags.\nDisables all flags enabled in the set.\nReturns the symmetric difference between the flags in <code>self</code> …\nToggles the specified flags in-place.\nReturns the union of between the flags in <code>self</code> and <code>other</code>.\nWrite dr{0-3} register based on provided enum variant.\nA struct describing a pointer to a descriptor table (GDT / …\nPointer to the memory region containing the DT.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the segment selector from the local descriptor …\nLoad the GDTR register with the specified base and limit.\nLoad the IDTR register with the specified base and limit.\nSize of the DT.\nLoads the segment selector into the selector field of the …\nRetrieve base and limit from the GDTR register.\nRetrieve base and limit from the IDTR register.\nlfence – Load Fence\nmfence – Memory Fence\nsfence – Store Fence\nRead 8 bits from port\nRead 32 bits from port\nRead 16 bits from port\nWrite 8 bits to port\nWrite 32 bits to port\nWrite 16 bits to port\nx86 External Interrupts (1-32).\n0: The fault was not caused by an instruction fetch. 1: …\nx86 Exception description (see also Intel Vol. 3a Chapter …\n0: The fault was caused by a non-present page. 1: The …\n0: The fault was not by protection keys. 1: There was a …\n0: The fault was not caused by reserved bit violation. 1: …\n0: The access causing the fault originated when the …\n0: The access causing the fault was a read. 1: The access …\nReturns the set containing all flags.\nReturns the intersection between the two sets of flags.\nDisables all flags disabled in the set.\nReturns the union of the two sets of flags.\nAdds the set of flags.\nReturns the raw value of the flags currently stored.\nReturns the left flags, but with all the right flags …\nToggles the set of flags.\nReturns the complement of this set of flags.\nReturns <code>true</code> if all of the flags in <code>other</code> are contained …\nReturns the difference between the flags in <code>self</code> and <code>other</code>.\nDisable Interrupts.\nReturns an empty set of flags.\nEnable Interrupts.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert from underlying bit representation, unless that …\nConvert from underlying bit representation, dropping any …\nConvert from underlying bit representation, preserving all …\nInserts the specified flags in-place.\nReturns the intersection between the flags in <code>self</code> and …\nReturns <code>true</code> if there are flags common to both <code>self</code> and …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if all flags are currently set.\nReturns <code>true</code> if no flags are currently stored.\nReturns the complement of this set of flags.\nRemoves the specified flags in-place.\nInserts or removes the specified flags depending on the …\nReturns the set difference of the two sets of flags.\nDisables all flags enabled in the set.\nReturns the symmetric difference between the flags in <code>self</code> …\nToggles the specified flags in-place.\nReturns the union of between the flags in <code>self</code> and <code>other</code>.\nSection 10.4.4, Local APIC Status and Location.\nBIOS Update Trigger Register.\nProcessor Hard Power-On Configuration  (R/W) Enables and …\nActual Performance Frequency Clock Count (RW)  See Table …\nAPIC Location and Status (R/W) See Table 35-2. See Section …\n(If CPUID.0AH: EAX[15:8] &gt;  0) &amp; IA32_PERF_CAPABILITIES[ 13…\n(If CPUID.0AH: EAX[15:8] &gt;  1) &amp; IA32_PERF_CAPABILITIES[ 13…\n(If CPUID.0AH: EAX[15:8] &gt;  2) &amp; IA32_PERF_CAPABILITIES[ 13…\n(If CPUID.0AH: EAX[15:8] &gt;  3) &amp; IA32_PERF_CAPABILITIES[ 13…\n(If CPUID.0AH: EAX[15:8] &gt;  4) &amp; IA32_PERF_CAPABILITIES[ 13…\n(If CPUID.0AH: EAX[15:8] &gt;  5) &amp; IA32_PERF_CAPABILITIES[ 13…\n(If CPUID.0AH: EAX[15:8] &gt;  6) &amp; IA32_PERF_CAPABILITIES[ 13…\n(If CPUID.0AH: EAX[15:8] &gt;  7) &amp; IA32_PERF_CAPABILITIES[ 13…\nBIOS Update Signature ID (R/W) See Table 35-2.\nBIOS Update Trigger Register (W)  See Table 35-2.\nClock Modulation (R/W)  See Table 35-2. …\nSystem Call Target Address the compatibility mode.\n06_2EH\nDebug Control (R/W)  Controls how several debug features …\nDS Save Area (R/W) See Table 35-2. Points to the DS buffer …\nIf (  CPUID.80000001.EDX.[bit  20] or  CPUID.80000001.EDX.…\nif CPUID.6H:ECX[3] = 1\nControl Features in IA-32 Processor (R/W) See Table 35-2 …\nFixed-Function Performance Counter Register 0 (R/W)  See …\nFixed-Function Performance Counter Register 1 (R/W)  See …\nFixed-Function Performance Counter Register 2 (R/W)  See …\nFixed-Function-Counter Control Register (R/W)  See Table …\nSystem Call Flag Mask (R/W)  See Table 35-2.\nMap of BASE Address of FS (R/W)  See Table 35-2.\nMap of BASE Address of GS (R/W)  See Table 35-2.\nSwap Target of BASE Address of GS (R/W) See Table 35-2.\nIA-32e Mode System Call Target Address (R/W)  See Table …\nSee Section 14.3.2.3., IA32_MCi_ADDR MSRs .  The …\nP6 Family Processors\nSee Section 15.3.2.1,  IA32_MCi_CTL MSRs.\nSee Table 35-2.\nSee Section 15.3.2.4,  IA32_MCi_MISC MSRs. The …\nSee Section 15.3.2.2, IA32_MCi_STATUS MSRS,  and Chapter …\n06_2EH\n06_2EH\nSee Table 35-2.\n06_2EH\n06_2EH\n06_2EH\n06_2EH\nSee Table 35-2.\n06_2EH\n06_2EH\n06_2EH\n06_2EH\nSee Table 35-2.\n06_2EH\n06_2EH\n06_2EH\n06_2EH\nSee Table 35-2.\n06_2EH\n06_2EH\n06_2EH\n06_2EH\nSee Table 35-2.\n06_2EH\n06_2EH\n06_2EH\n06_2EH\nSee Table 35-2.\n06_2EH\n06_2EH\n06_2EH\n06_2EH\nSee Table 35-2.\n06_2EH\n06_2EH\n06_2EH\n06_2EH\nSee Table 35-2.\n06_2EH\n06_2EH\n06_2EH\n06_2EH\nSee Table 35-2.\n06_2EH\n06_2EH\n06_2EH\n06_2EH\nSee Table 35-2.\n06_2EH\n06_2EH\nSee Section 15.3.2.3, IA32_MCi_ADDR MSRs. The …\nP6 Family Processors\nSee Section 15.3.2.1,  IA32_MCi_CTL MSRs.\nSee Table 35-2.\nSee Section 15.3.2.4,  IA32_MCi_MISC MSRs. The …\nSee Section 15.3.2.2, IA32_MCi_STATUS MSRS,  and Chapter …\n06_2EH\n06_2EH\nSee Table 35-2.\n06_2EH\n06_2EH\n06_2EH\n06_2EH\nSee Table 35-2.\n06_2EH\n06_2EH\nSee Section 15.3.2.3, IA32_MCi_ADDR MSRs. The …\nP6 Family Processors\nSee Section 15.3.2.1,  IA32_MCi_CTL MSRs.\nSee Table 35-2.\nSee Section 15.3.2.4,  IA32_MCi_MISC MSRs. The …\nSee Section 15.3.2.2, IA32_MCi_STATUS MSRS,  and Chapter …\nSee Section 15.3.2.3, IA32_MCi_ADDR MSRs. The …\nP6 Family Processors\nSee Section 15.3.2.1,  IA32_MCi_CTL MSRs.\nSee Table 35-2.\nSee Section 15.3.2.4,  IA32_MCi_MISC MSRs. The …\nSee Section 15.3.2.2, IA32_MCi_STATUS MSRS,  and Chapter …\nSee Section 15.3.2.3, IA32_MCi_ADDR MSRs. The …\nP6 Family Processors\nSee Section 15.3.2.1,  IA32_MCi_CTL MSRs.\nSee Table 35-2.\nSee Section 15.3.2.4,  IA32_MCi_MISC MSRs.   The …\nSee Section 15.3.2.2, IA32_MCi_STATUS MSRS,  and Chapter …\n06_0FH\n06_0FH\nSee Table 35-2.\n06_0FH\n06_0FH\n06_1DH\n06_1DH\nSee Table 35-2.\nMisc MAC information of Integrated I/O. (R/O) see Section …\n06_1DH\n06_1AH\n06_1AH\nSee Table 35-2.\n06_1AH\n06_1AH\n06_1AH\n06_1AH\nSee Table 35-2.\n06_1AH\n06_1AH\n06_2EH\n06_2EH\nSee Table 35-2.\n06_2EH\n06_2EH\nMachine Check Capabilities (R) See Table 35-2. See Section …\nMachine Check Feature Enable (R/W) See Table 35-2. See …\nMachine Check Status. (R) See Table 35-2. See Section …\nSee Section 8.10.5, Monitor/Mwait Address  Range …\nSee Section 8.10.5, Monitor/Mwait Address Range …\nMaximum Performance Frequency Clock Count (RW)  See Table …\nMTRR Information See Section 11.11.1, MTRR Feature  …\nDefault Memory Types (R/W)  Sets the memory type for the …\nFixed Range MTRR See Section 11.11.2.2, Fixed Range MTRRs.\nFixed Range MTRR See Section 11.11.2.2, Fixed Range MTRRs.\nFixed Range MTRR See Section 11.11.2.2, Fixed Range MTRRs.\nFixed Range MTRR See Section 11.11.2.2, Fixed Range MTRRs .\nFixed Range MTRR See Section 11.11.2.2, Fixed Range MTRRs .\nFixed Range MTRR See Section 11.11.2.2, Fixed Range MTRRs.\nFixed Range MTRR See Section 11.11.2.2, Fixed Range MTRRs.\nFixed Range MTRR See Section 11.11.2.2, Fixed Range MTRRs.\nFixed Range MTRR See Section 11.11.2.2, Fixed Range MTRRs.\nFixed Range MTRR See Section 11.11.2.2, Fixed Range MTRRs.\nFixed Range MTRR See Section 11.11.2.2, Fixed Range MTRRs.\nVariable Range Base MTRR See Section 11.11.2.3, Variable …\nVariable Range Mask MTRR See Section 11.11.2.3, Variable …\nVariable Range Mask MTRR See Section 11.11.2.3, Variable …\nVariable Range Mask MTRR See Section 11.11.2.3, Variable …\nVariable Range Mask MTRR See Section 11.11.2.3, Variable …\nVariable Range Mask MTRR See Section 11.11.2.3, Variable …\nVariable Range Mask MTRR See Section 11.11.2.3, Variable …\nVariable Range Mask MTRR See Section 11.11.2.3, Variable …\nif IA32_MTRR_CAP[7:0] &gt;  8\nif IA32_MTRR_CAP[7:0] &gt;  9\nVariable Range Mask MTRR See Section 11.11.2.3, Variable …\nVariable Range Mask MTRR See Section 11.11.2.3, Variable …\nVariable Range Mask MTRR See Section 11.11.2.3, Variable …\nVariable Range Mask MTRR See Section 11.11.2.3, Variable …\nVariable Range Mask MTRR See Section 11.11.2.3, Variable …\nVariable Range Mask MTRR See Section 11.11.2.3, Variable …\nVariable Range Mask MTRR See Section 11.11.2.3, Variable …\nVariable Range Mask MTRR See Section 11.11.2.3, Variable …\nif IA32_MTRR_CAP[7:0] &gt;  8\nif IA32_MTRR_CAP[7:0] &gt;  9\nSee Section 35.16, MSRs in Pentium Processors.\nSee Section 35.16, MSRs in Pentium Processors.\nIf CPUID.06H: EAX[6] = 1\nIf CPUID.06H: EAX[6] = 1\nPage Attribute Table See Section 11.11.2.2, Fixed Range …\nPerformance Event Select for Counter 0 (R/W) Supports all …\nPerformance Event Select for Counter 1 (R/W) Supports all …\nPerformance Event Select for Counter 2 (R/W) Supports all …\nPerformance Event Select for Counter 3 (R/W) Supports all …\nSee Table 35-2; If CPUID.0AH:EAX[15:8] = 8\nSee Table 35-2; If CPUID.0AH:EAX[15:8] = 8\nSee Table 35-2; If CPUID.0AH:EAX[15:8] = 8\nSee Table 35-2; If CPUID.0AH:EAX[15:8] = 8\nSee Table 35-2. See Section 17.4.1, IA32_DEBUGCTL MSR.\nSee Table 35-2. See Section 14.1, Enhanced Intel  …\nSee Table 35-2. See Section 18.4.2, Global Counter Control …\nSee Table 35-2. See Section 18.4.2, Global Counter Control …\nSee Table 35-2. See Section 18.4.2, Global Counter Control …\nSee Table 35-2. See Section 14.1, Enhanced Intel  …\n06_0FH\nPlatform ID (R)  See Table 35-2. The operating system can …\nPerformance Counter Register  See Table 35-2.\nPerformance Counter Register  See Table 35-2.\nPerformance Counter Register  See Table 35-2.\nPerformance Counter Register  See Table 35-2.\nPerformance Counter Register  See Table 35-2.\nPerformance Counter Register  See Table 35-2.\nPerformance Counter Register  See Table 35-2.\nPerformance Counter Register  See Table 35-2.\nIf ( CPUID.(EAX=07H,  ECX=0):EBX.[bit 12] = 1 )\nIf ( CPUID.(EAX=07H,  ECX=0):EBX.[bit 12] = 1 )\nIf ( CPUID.(EAX=07H,  ECX=0):EBX.[bit 12] = 1 )\nIf IA32_VMX_MISC[bit 15])\nSMM Monitor Configuration (R/W) See Table 35-2.\nSee Table 35-2.\nIf IA32_MTRR_CAP[SMRR]  = 1\nSystem Call Target Address (R/W)  See Table 35-2.\nCS register target for CPL 0 code (R/W) See Table 35-2. …\nCPL 0 code entry point (R/W) See Table 35-2. See Section …\nStack pointer for CPL 0 stack (R/W) See Table 35-2. See …\nThermal Interrupt Control (R/W) See Section 14.5.2, …\nThermal Monitor Status (R/W) See Section 14.5.2, Thermal …\nSee Section 17.13, Time-Stamp Counter,  and see Table 35-2.\nPer-Logical-Processor TSC ADJUST (R/W) See Table 35-2.\nAUXILIARY TSC Signature. (R/W) See Table 35-2 and Section  …\nTSC Target of Local APIC s TSC Deadline Mode (R/W)  See …\nReporting Register of Basic VMX Capabilities (R/O) See …\nCapability Reporting Register of CR0 Bits Fixed to 0 (R/O) …\nCapability Reporting Register of CR0 Bits Fixed to 1 (R/O) …\nCapability Reporting Register of CR4 Bits Fixed to 0 (R/O) …\nCapability Reporting Register of CR4 Bits Fixed to 1 (R/O) …\nIf CPUID.01H:ECX.[bit 5] = 1\nIf CPUID.01H:ECX.[bit 5] = 1\nCapability Reporting Register of VM-entry Controls (R/O) …\nIf ( CPUID.01H:ECX.[bit 5],  IA32_VMX_PROCBASED_C TLS[bit …\nCapability Reporting Register of EPT and VPID (R/O)  See …\nCapability Reporting Register of VM-exit Controls (R/O) …\nCapability Reporting Register of VM-function Controls …\nReporting Register of Miscellaneous VMX Capabilities (R/O) …\nCapability Reporting Register of Pin-based VM-execution  …\nCapability Reporting Register of Primary Processor-based  …\nCapability Reporting Register of Secondary Processor-based …\nCapability Reporting Register of VM-entry Flex Controls …\nCapability Reporting Register of VM-exit Flex Controls …\nCapability Reporting Register of Pin-based VM-execution …\nCapability Reporting Register of Primary Processor-based  …\nCapability Reporting Register of VMCS Field Enumeration …\nIf( CPUID.01H:ECX.[bit 5] =  1 and IA32_VMX_BASIC[bit 55] )\nx2APIC ID register (R/O) See x2APIC Specification.\nx2APIC Current Count register (R/O)\nx2APIC Divide Configuration register (R/W)\nx2APIC End of Interrupt. If ( CPUID.01H:ECX.[bit 21]  = 1 )\nError Status Register. If ( CPUID.01H:ECX.[bit 21]  = 1 )\nx2APIC Interrupt Command register (R/W)\nx2APIC Initial Count register (R/W)\nx2APIC Interrupt Request register bits [31:0] (R/O)\nx2APIC Interrupt Request register bits [63:32] (R/O)\nx2APIC Interrupt Request register bits [95:64] (R/O)\nx2APIC Interrupt Request register bits [127:96] (R/O)\nx2APIC Interrupt Request register bits [159:128] (R/O)\nx2APIC Interrupt Request register bits [191:160] (R/O)\nx2APIC Interrupt Request register bits [223:192] (R/O)\nx2APIC Interrupt Request register bits [255:224] (R/O)\nx2APIC In-Service register bits [31:0] (R/O)\nx2APIC In-Service register bits [63:32] (R/O)\nx2APIC In-Service register bits [95:64] (R/O)\nx2APIC In-Service register bits [127:96] (R/O)\nx2APIC In-Service register bits [159:128] (R/O)\nx2APIC In-Service register bits [191:160] (R/O)\nx2APIC In-Service register bits [223:192] (R/O)\nx2APIC In-Service register bits [255:224] (R/O)\nx2APIC Logical Destination register (R/O)\nx2APIC LVT Corrected Machine Check Interrupt register (R/W)\nIf ( CPUID.01H:ECX.[bit 21]  = 1 )\nIf ( CPUID.01H:ECX.[bit 21]  = 1 )\nIf ( CPUID.01H:ECX.[bit 21]  = 1 )\nx2APIC LVT Performance Monitor register (R/W)\nx2APIC LVT Thermal Sensor Interrupt register (R/W)\nx2APIC LVT Timer Interrupt register (R/W)\nx2APIC Processor Priority register (R/O)\nIf ( CPUID.01H:ECX.[bit 21]  = 1 )\nx2APIC Spurious Interrupt Vector register (R/W)\nx2APIC Trigger Mode register bits [31:0] (R/O)\nx2APIC Trigger Mode register bits [63:32] (R/O)\nx2APIC Trigger Mode register bits [95:64] (R/O)\nx2APIC Trigger Mode register bits [127:96] (R/O)\nx2APIC Trigger Mode register bits [159:128] (R/O)\nx2APIC Trigger Mode register bits [191:160] (R/O)\nx2APIC Trigger Mode register bits [223:192] (R/O)\nx2APIC Trigger Mode register bits [255:224] (R/O)\nx2APIC Task Priority register (R/W)\nx2APIC Version. If ( CPUID.01H:ECX.[bit 21]  = 1 )\nDefined in MCA architecture but not implemented in the P6 …\nDefined in MCA architecture but not implemented in the P6 …\nBit definitions same as MC0_STATUS.\nDefined in MCA architecture but not implemented in the P6 …\nBit definitions same as MC0_STATUS.\nDefined in MCA architecture but not implemented in the P6 …\nBit definitions same as MC0_STATUS.\nDefined in MCA architecture but not implemented in P6 …\nDefined in MCA architecture but not implemented in the P6 …\nBit definitions same as MC0_STATUS, except bits 0, 4, 57, …\nSee Section 18.12.1, ESCR MSRs.\nSee Section 18.12.1, ESCR MSRs.\nUncore B-box 0 perfmon local box control MSR.\nUncore B-box 0 perfmon local box overflow control MSR.\nUncore B-box 0 perfmon local box status MSR.\nUncore B-box 0 perfmon counter MSR.\nUncore B-box 0 perfmon counter MSR.\nUncore B-box 0 perfmon counter MSR.\nUncore B-box 0 perfmon counter MSR.\nUncore B-box 0 perfmon event select MSR.\nUncore B-box 0 perfmon event select MSR.\nUncore B-box 0 perfmon event select MSR.\nUncore B-box 0 perfmon event select MSR.\nUncore B-box 0 perfmon local box mask MSR.\nUncore B-box 0 perfmon local box match MSR.\nUncore B-box 1 perfmon local box control MSR.\nUncore B-box 1 perfmon local box overflow control MSR.\nUncore B-box 1 perfmon local box status MSR.\nUncore B-box 1 perfmon counter MSR.\nUncore B-box 1 perfmon counter MSR.\nUncore B-box 1 perfmon counter MSR.\nUncore B-box 1 perfmon counter MSR.\nUncore B-box 1 perfmon event select MSR.\nUncore B-box 1 perfmon event select MSR.\nUncore B-box 1 perfmon event select MSR.\nUncore B-box 1vperfmon event select MSR.\nUncore B-box 1 perfmon local box mask MSR.\nUncore B-box 1 perfmon local box match MSR.\nSee Section 18.12.3, CCCR MSRs.\nSee Section 18.12.3, CCCR MSRs.\nSee Section 18.12.3, CCCR MSRs.\nSee Section 18.12.3, CCCR MSRs.\nSee Section 18.12.2, Performance Counters.\nSee Section 18.12.2, Performance Counters.\nSee Section 18.12.2, Performance Counters.\nSee Section 18.12.2, Performance Counters.\nSee Section 18.12.1, ESCR MSRs.\nSee Section 18.12.1, ESCR MSRs.\nSee Section 18.12.1, ESCR MSRs.\nSee Section 18.12.1, ESCR MSRs.\nUncore C-box 0 perfmon local box control MSR.\nUncore C-box 0 perfmon local box overflow control MSR.\nUncore C-box 0 perfmon local box status MSR.\nUncore C-box 0 perfmon counter MSR.\nUncore C-box 0 perfmon counter MSR.\nUncore C-box 0 perfmon counter MSR.\nUncore C-box 0 perfmon counter MSR.\nUncore C-box 0 perfmon counter MSR.\nUncore C-box 0 perfmon counter MSR.\nUncore C-box 0 perfmon event select MSR.\nUncore C-box 0 perfmon event select MSR.\nUncore C-box 0 perfmon event select MSR.\nUncore C-box 0 perfmon event select MSR.\nUncore C-box 0 perfmon event select MSR.\nUncore C-box 0 perfmon event select MSR.\nUncore C-box 1 perfmon local box control MSR.\nUncore C-box 1 perfmon local box overflow control MSR.\nUncore C-box 1 perfmon local box status MSR.\nUncore C-box 1 perfmon counter MSR.\nUncore C-box 1 perfmon counter MSR.\nUncore C-box 1 perfmon counter MSR.\nUncore C-box 1 perfmon counter MSR.\nUncore C-box 1 perfmon counter MSR.\nUncore C-box 1 perfmon counter MSR.\nUncore C-box 1 perfmon event select MSR.\nUncore C-box 1 perfmon event select MSR.\nUncore C-box 1 perfmon event select MSR.\nUncore C-box 1 perfmon event select MSR.\nUncore C-box 1 perfmon event select MSR.\nUncore C-box 1 perfmon event select MSR.\nUncore C-box 2 perfmon local box control MSR.\nUncore C-box 2 perfmon local box overflow control MSR.\nUncore C-box 2 perfmon local box status MSR.\nUncore C-box 2 perfmon counter MSR.\nUncore C-box 2 perfmon counter MSR.\nUncore C-box 2 perfmon counter MSR.\nUncore C-box 2 perfmon counter MSR.\nUncore C-box 2 perfmon counter MSR.\nUncore C-box 2 perfmon counter MSR.\nUncore C-box 2 perfmon event select MSR.\nUncore C-box 2 perfmon event select MSR.\nUncore C-box 2 perfmon event select MSR.\nUncore C-box 2 perfmon event select MSR.\nUncore C-box 2 perfmon event select MSR.\nUncore C-box 2 perfmon event select MSR.\nUncore C-box 3 perfmon local box control MSR.\nUncore C-box 3 perfmon local box overflow control MSR.\nUncore C-box 3 perfmon local box status MSR.\nUncore C-box 3 perfmon counter MSR.\nUncore C-box 3 perfmon counter MSR.\nUncore C-box 3 perfmon counter MSR.\nUncore C-box 3 perfmon counter MSR.\nUncore C-box 3 perfmon counter MSR.\nUncore C-box 3 perfmon counter MSR.\nUncore C-box 3 perfmon event select MSR.\nUncore C-box 3 perfmon event select MSR.\nUncore C-box 3 perfmon event select MSR.\nUncore C-box 3 perfmon event select MSR.\nUncore C-box 3 perfmon event select MSR.\nUncore C-box 3 perfmon event select MSR.\nUncore C-box 4 perfmon local box control MSR.\nUncore C-box 4 perfmon local box overflow control MSR.\nUncore C-box 4 perfmon local box status MSR.\nUncore C-box 4 perfmon counter MSR.\nUncore C-box 4 perfmon counter MSR.\nUncore C-box 4 perfmon counter MSR.\nUncore C-box 4 perfmon counter MSR.\nUncore C-box 4 perfmon counter MSR.\nUncore C-box 4 perfmon counter MSR.\nUncore C-box 4 perfmon event select MSR.\nUncore C-box 4 perfmon event select MSR.\nUncore C-box 4 perfmon event select MSR.\nUncore C-box 4 perfmon event select MSR.\nUncore C-box 4 perfmon event select MSR.\nUncore C-box 4 perfmon event select MSR.\nUncore C-box 5 perfmon local box control MSR.\nUncore C-box 5 perfmon local box overflow control MSR.\nUncore C-box 5 perfmon local box status MSR.\nUncore C-box 5 perfmon counter MSR.\nUncore C-box 5 perfmon counter MSR.\nUncore C-box 5 perfmon counter MSR.\nUncore C-box 5 perfmon counter MSR.\nUncore C-box 5 perfmon counter MSR.\nUncore C-box 5 perfmon counter MSR.\nUncore C-box 5 perfmon event select MSR.\nUncore C-box 5 perfmon event select MSR.\nUncore C-box 5 perfmon event select MSR.\nUncore C-box 5 perfmon event select MSR.\nUncore C-box 5 perfmon event select MSR.\nUncore C-box 5 perfmon event select MSR.\nUncore C-box 6 perfmon local box control MSR.\nUncore C-box 6 perfmon local box overflow control MSR.\nUncore C-box 6 perfmon local box status MSR.\nUncore C-box 6 perfmon counter MSR.\nUncore C-box 6 perfmon counter MSR.\nUncore C-box 6 perfmon counter MSR.\nUncore C-box 6 perfmon counter MSR.\nUncore C-box 6 perfmon counter MSR.\nUncore C-box 6 perfmon counter MSR.\nUncore C-box 6 perfmon event select MSR.\nUncore C-box 6 perfmon event select MSR.\nUncore C-box 6 perfmon event select MSR.\nUncore C-box 6 perfmon event select MSR.\nUncore C-box 6 perfmon event select MSR.\nUncore C-box 6 perfmon event select MSR.\nUncore C-box 7 perfmon local box control MSR.\nUncore C-box 7 perfmon local box overflow control MSR.\nUncore C-box 7 perfmon local box status MSR.\nUncore C-box 7 perfmon counter MSR.\nUncore C-box 7 perfmon counter MSR.\nUncore C-box 7 perfmon counter MSR.\nUncore C-box 7 perfmon counter MSR.\nUncore C-box 7 perfmon counter MSR.\nUncore C-box 7 perfmon counter MSR.\nUncore C-box 7 perfmon event select MSR.\nUncore C-box 7 perfmon event select MSR.\nUncore C-box 7 perfmon event select MSR.\nUncore C-box 7 perfmon event select MSR.\nUncore C-box 7 perfmon event select MSR.\nUncore C-box 7 perfmon event select MSR.\nUncore C-box 8 perfmon local box control MSR.\nUncore C-box 8 perfmon local box overflow control MSR.\nUncore C-box 8 perfmon local box status MSR.\nUncore C-box 8 perfmon counter MSR.\nUncore C-box 8 perfmon counter MSR.\nUncore C-box 8 perfmon counter MSR.\nUncore C-box 8 perfmon counter MSR.\nUncore C-box 8 perfmon counter MSR.\nUncore C-box 8 perfmon counter MSR.\nUncore C-box 8 perfmon event select MSR.\nUncore C-box 8 perfmon event select MSR.\nUncore C-box 8 perfmon event select MSR.\nUncore C-box 8 perfmon event select MSR.\nUncore C-box 8 perfmon event select MSR.\nUncore C-box 8 perfmon event select MSR.\nUncore C-box 9 perfmon local box control MSR.\nUncore C-box 9 perfmon local box overflow control MSR.\nUncore C-box 9 perfmon local box status MSR.\nUncore C-box 9 perfmon counter MSR.\nUncore C-box 9 perfmon counter MSR.\nUncore C-box 9 perfmon counter MSR.\nUncore C-box 9 perfmon counter MSR.\nUncore C-box 9 perfmon counter MSR.\nUncore C-box 9 perfmon counter MSR.\nUncore C-box 9 perfmon event select MSR.\nUncore C-box 9 perfmon event select MSR.\nUncore C-box 9 perfmon event select MSR.\nUncore C-box 9 perfmon event select MSR.\nUncore C-box 9 perfmon event select MSR.\nUncore C-box 9 perfmon event select MSR.\nConfigTDP Control (R/W)\nConfigTDP Level 1 ratio and power level (R/O)\nConfigTDP Level 2 ratio and power level (R/O)\nNominal TDP Ratio (R/O)\nNote: C-state values are processor specific C-state code …\nNote: C-state values are processor specific C-state code …\nNote: C-state values are processor specific C-state code …\nNote: C-state values are processor specific C-state code …\nNote: C-state values are processor specific C-state code …\nSee Section 18.12.1, ESCR MSRs.\nSee Section 18.12.1, ESCR MSRs.\nSee Section 18.12.1, ESCR MSRs.\nSee Section 18.12.1, ESCR MSRs.\nSee Section 18.12.1, ESCR MSRs.\nSee Section 18.12.1, ESCR MSRs.\nSee Section 18.12.1, ESCR MSRs.\nSee Section 18.12.1, ESCR MSRs.\nDebug Control (R/W)  Controls how several debug features …\nDebug Control (R/W)  Controls how several debug features …\nDRAM Energy Status (R/O)  See Section 14.7.5, DRAM RAPL …\nDRAM Performance Throttling Status (R/O) See Section …\nDRAM RAPL Parameters (R/W) See Section 14.7.5, DRAM RAPL …\nDRAM RAPL Power Limit Control (R/W)  See Section 14.7.5, …\nProcessor Frequency Configuration The bit field layout of …\nProcessor Hard Power-On Configuration (R/W) Enables and …\nProcessor Soft Power-On Configuration (R/W)  Enables and …\nProcessor Hard Power-On Configuration (R/W) Enables and  …\nEFSB DRDY Event Control and Counter Register (R/W)  See …\nEFSB DRDY Event Control and Counter  Register (R/W)\nGBUSQ Event Control and Counter  Register (R/W) See …\nGBUSQ Event Control/Counter Register (R/W) Apply to Intel …\nGSNPQ Event Control and Counter  Register (R/W)  See …\nGSNPQ Event Control/Counter Register (R/W) Apply to Intel …\nFSB Event Control and Counter Register (R/W)  See Section …\nFSB Event Control/Counter Register (R/W) Apply to Intel …\nFSB Event Control/Counter Register (R/W) Apply to Intel …\nFSB Event Control/Counter Register (R/W) Apply to Intel …\nL3/FSB Common Control Register (R/W) Apply to Intel Xeon …\nMC Bank Error Configuration (R/W)\nSee Section 18.12.1, ESCR MSRs.\nSee Section 18.12.1, ESCR MSRs.\nSee Section 18.12.3, CCCR MSRs.\nSee Section 18.12.3, CCCR MSRs.\nSee Section 18.12.3, CCCR MSRs.\nSee Section 18.12.3, CCCR MSRs.\nSee Section 18.12.2, Performance Counters.\nSee Section 18.12.2, Performance Counters.\nSee Section 18.12.2, Performance Counters.\nSee Section 18.12.2, Performance Counters.\nSee Section 18.12.1, ESCR MSRs.\nSee Section 18.12.1, ESCR MSRs.\nSee Section 18.12.1, ESCR MSRs.\nSee Section 18.12.1, ESCR MSRs.\nScaleable Bus Speed(RO) This field indicates the intended …\nTrace End Address 0\nTrace Start Address 0\nTrace End Address 1\nTrace Start Address 1\nTrace End Address 3\nTrace Start Address 3\nTrace End Address 4\nTrace Start Address 4\nTrace Filter CR3 Match Register (R/W)\nTrace Control Register (R/W)\nTrace Output Base Register (R/W)\nTrace Output Mask Pointers Register (R/W)\nTracing Status Register (R/W)\nTSX Ctrl Register for TSX Async Abot (TAA) Migration. See …\nIFSB BUSQ Event Control and Counter  Register (R/W) See …\nIFSB BUSQ Event Control and Counter Register (R/W)\nIFSB Latency Event Counter Register  (R/W)  See Section …\nIFSB Latency Event Control Register  (R/W) See Section …\nIFSB SNPQ Event Control and Counter  Register (R/W)  See …\nIFSB SNPQ Event Control and Counter  Register (R/W)\nSee Section 18.12.3, CCCR MSRs.\nSee Section 18.12.3, CCCR MSRs.\nSee Section 18.12.3, CCCR MSRs.\nSee Section 18.12.3, CCCR MSRs.\nSee Section 18.12.3, CCCR MSRs.\nSee Section 18.12.3, CCCR MSRs.\nSee Section 18.12.2, Performance Counters.\nSee Section 18.12.2, Performance Counters.\nSee Section 18.12.1, ESCR MSRs. This MSR is not available …\nSee Section 18.12.1, ESCR MSRs. This MSR is not available …\nSee Section 18.12.1, ESCR MSRs.\nSee Section 18.12.1, ESCR MSRs.\nSee Section 18.12.1, ESCR MSRs.\nSee Section 18.12.1, ESCR MSRs.\nSee Section 18.12.1, ESCR MSRs.\nLast Branch Record 0 (R/W)  One of four last branch record …\nLast Branch Record 0 From IP (R/W) One of eight pairs of …\nLast Branch Record 0 (R/W)  One of 16 pairs of last branch …\nLast Branch Record 1 (R/W) See description of …\nLast Branch Record 10 From IP (R/W) See description of …\nLast Branch Record 10 To IP (R/W) See description of …\nLast Branch Record 11 From IP (R/W) See description of …\nLast Branch Record 11 To IP (R/W) See description of …\nLast Branch Record 12 From IP (R/W) See description of …\nLast Branch Record 12 To IP (R/W) See description of …\nLast Branch Record 13 From IP (R/W) See description of …\nLast Branch Record 13 To IP (R/W) See description of …\nLast Branch Record 14 From IP (R/W) See description of …\nLast Branch Record 14 To IP (R/W) See description of …\nLast Branch Record 15 From IP (R/W) See description of …\nLast Branch Record 15 To IP (R/W) See description of …\nLast Branch Record 1 From IP (R/W) See description of …\nLast Branch Record 1 To IP (R/W) See description of …\nLast Branch Record 2 See description of the …\nLast Branch Record 2 From IP (R/W) See description of …\nLast Branch Record 2 To IP (R/W) See description of …\nLast Branch Record 3 See description of the …\nLast Branch Record 3 From IP (R/W) See description of …\nLast Branch Record 3 To IP (R/W) See description of …\nLast Branch Record 4 (R/W) See description of …\nLast Branch Record 4 From IP (R/W) See description of …\nLast Branch Record 4 To IP (R/W) See description of …\nLast Branch Record 5 (R/W) See description of …\nLast Branch Record 5 From IP (R/W) See description of …\nLast Branch Record 5 To IP (R/W) See description of …\nLast Branch Record 6 (R/W) See description of …\nLast Branch Record 6 From IP (R/W) See description of …\nLast Branch Record 6 To IP (R/W) See description of …\nLast Branch Record 7 (R/W) See description of …\nLast Branch Record 7 From IP (R/W) See description of …\nLast Branch Record 7 To IP (R/W) See description of …\nLast Branch Record 8 From IP (R/W) See description of …\nLast Branch Record 8 To IP (R/W) See description of …\nLast Branch Record 9 From IP (R/W) See description of …\nLast Branch Record 9 To IP (R/W) See description of …\nLast Branch Record Stack TOS (R/W)  Contains an index (0-3 …\nLast Branch Record Filtering Select Register (R/W)  See …\nLast Exception Record From Linear IP (R)  Contains a …\nLast Exception Record To Linear IP (R)  This area contains …\nUncore M-box 0 perfmon local box address mask MSR.\nUncore M-box 0 perfmon local box address match MSR.\nUncore M-box 0 perfmon local box control MSR.\nUncore M-box 0 perfmon local box overflow control MSR.\nUncore M-box 0 perfmon local box status MSR.\nUncore M-box 0 perfmon counter MSR.\nUncore M-box 0 perfmon counter MSR.\nUncore M-box 0 perfmon counter MSR.\nUncore M-box 0 perfmon counter MSR.\nUncore M-box 0 perfmon counter MSR.\nUncore M-box 0 perfmon counter MSR.\nUncore M-box 0 perfmon DSP unit select MSR.\nUncore M-box 0 perfmon event select MSR.\nUncore M-box 0 perfmon event select MSR.\nUncore M-box 0 perfmon event select MSR.\nUncore M-box 0 perfmon event select MSR.\nUncore M-box 0 perfmon event select MSR.\nUncore M-box 0 perfmon event select MSR.\nUncore M-box 0 perfmon ISS unit select MSR.\nUncore M-box 0 perfmon MAP unit select MSR.\nUncore M-box 0 perfmon local box address match/mask config …\nUncore M-box 0 perfmon MIC THR select MSR.\nUncore M-box 0 perfmon PGT unit select MSR.\nUncore M-box 0 perfmon PLD unit select MSR.\nUncore M-box 0 perfmon time stamp unit select MSR.\nUncore M-box 0 perfmon ZDP unit select MSR.\nUncore M-box 1 perfmon local box address mask MSR.\nUncore M-box 1 perfmon local box address match MSR.\nUncore M-box 1 perfmon local box control MSR.\nUncore M-box 1 perfmon local box overflow control MSR.\nUncore M-box 1 perfmon local box status MSR.\nUncore M-box 1 perfmon counter MSR.\nUncore M-box 1 perfmon counter MSR.\nUncore M-box 1 perfmon counter MSR.\nUncore M-box 1 perfmon counter MSR.\nUncore M-box 1 perfmon counter MSR.\nUncore M-box 1 perfmon counter MSR.\nUncore M-box 1 perfmon DSP unit select MSR.\nUncore M-box 1 perfmon event select MSR.\nUncore M-box 1 perfmon event select MSR.\nUncore M-box 1 perfmon event select MSR.\nUncore M-box 1 perfmon event select MSR.\nUncore M-box 1 perfmon event select MSR.\nUncore M-box 1 perfmon event select MSR.\nUncore M-box 1 perfmon ISS unit select MSR.\nUncore M-box 1 perfmon MAP unit select MSR.\nUncore M-box 1 perfmon local box address match/mask config …\nUncore M-box 1 perfmon MIC THR select MSR.\nUncore M-box 1 perfmon PGT unit select MSR.\nUncore M-box 1 perfmon PLD unit select MSR.\nUncore M-box 1 perfmon time stamp unit select MSR.\nUncore M-box 1 perfmon ZDP unit select MSR.\nSee Section 15.3.2.4,  IA32_MCi_MISC MSRs.\nSee Section 15.3.2.3, IA32_MCi_ADDR MSRs.\nSee Section 15.3.2.1,  IA32_MCi_CTL MSRs.\nSee Section 15.3.2.4,  IA32_MCi_MISC MSRs.\nSee Section 15.3.2.2, IA32_MCi_STATUS MSRS,  and Chapter …\nSee Section 15.3.2.3, IA32_MCi_ADDR MSRs.\nSee Section 15.3.2.1,  IA32_MCi_CTL MSRs.\nSee Section 15.3.2.4,  IA32_MCi_MISC MSRs.\nSee Section 15.3.2.2, IA32_MCi_STATUS MSRS,  and Chapter …\nSee Section 15.3.2.3, IA32_MCi_ADDR MSRs.\nSee Section 15.3.2.1,  IA32_MCi_CTL MSRs.\nSee Section 15.3.2.4,  IA32_MCi_MISC MSRs.\nSee Section 15.3.2.2, IA32_MCi_STATUS MSRS,  and Chapter …\nSee Section 15.3.2.3, IA32_MCi_ADDR MSRs.\nSee Section 15.3.2.1,  IA32_MCi_CTL MSRs.\nSee Section 15.3.2.4,  IA32_MCi_MISC MSRs.\nSee Section 15.3.2.2, IA32_MCi_STATUS MSRS,  and Chapter …\nSee Section 15.3.2.3, IA32_MCi_ADDR MSRs.\nSee Section 15.3.2.1,  IA32_MCi_CTL MSRs.\nSee Section 15.3.2.4,  IA32_MCi_MISC MSRs.\nSee Section 15.3.2.2, IA32_MCi_STATUS MSRS,  and Chapter …\nSee Section 15.3.2.3, IA32_MCi_ADDR MSRs.\nSee Section 15.3.2.1,  IA32_MCi_CTL MSRs.\nSee Section 15.3.2.4,  IA32_MCi_MISC MSRs.\nSee Section 15.3.2.2, IA32_MCi_STATUS MSRS,  and Chapter …\nSee Section 15.3.2.3, IA32_MCi_ADDR MSRs.\nSee Section 15.3.2.1,  IA32_MCi_CTL MSRs.\nSee Section 15.3.2.4,  IA32_MCi_MISC MSRs.\nSee Section 15.3.2.2, IA32_MCi_STATUS MSRS,  and Chapter …\nSee Section 15.3.2.3, IA32_MCi_ADDR MSRs.\nSee Section 15.3.2.1,  IA32_MCi_CTL MSRs.\nSee Section 15.3.2.4,  IA32_MCi_MISC MSRs.\nSee Section 15.3.2.2, IA32_MCi_STATUS MSRS,  and Chapter …\nSee Section 15.3.2.3, IA32_MCi_ADDR MSRs.\nSee Section 15.3.2.1,  IA32_MCi_CTL MSRs.\nSee Section 15.3.2.4,  IA32_MCi_MISC MSRs.\nSee Section 15.3.2.2, IA32_MCi_STATUS MSRS,  and Chapter …\nSee Section 15.3.2.3, IA32_MCi_ADDR MSRs.\nSee Section 15.3.2.1,  IA32_MCi_CTL MSRs.\nSee Section 15.3.2.4,  IA32_MCi_MISC MSRs.\nSee Section 15.3.2.2, IA32_MCi_STATUS MSRS,  and Chapter …\nSee Section 15.3.2.4,  IA32_MCi_MISC MSRs.\nSee Section 15.3.2.3, IA32_MCi_ADDR MSRs.\nSee Section 15.3.2.1,  IA32_MCi_CTL MSRs.\nSee Section 15.3.2.4,  IA32_MCi_MISC MSRs.\nSee Section 15.3.2.2, IA32_MCi_STATUS MSRS,  and Chapter …\nSee Section 15.3.2.3, IA32_MCi_ADDR MSRs.\nSee Section 15.3.2.1,  IA32_MCi_CTL MSRs.\nSee Section 15.3.2.4,  IA32_MCi_MISC MSRs.\nSee Section 15.3.2.2, IA32_MCi_STATUS MSRS,  and Chapter …\nSee Section 15.3.2.3, IA32_MCi_ADDR MSRs.\nSee Section 15.3.2.1,  IA32_MCi_CTL MSRs.\nSee Section 15.3.2.4,  IA32_MCi_MISC MSRs.\nSee Section 15.3.2.2, IA32_MCi_STATUS MSRS,  and Chapter …\nSee Section 15.3.2.3, IA32_MCi_ADDR MSRs.\nSee Section 15.3.2.1,  IA32_MCi_CTL MSRs.\nSee Section 15.3.2.4,  IA32_MCi_MISC MSRs.\nSee Section 15.3.2.2, IA32_MCi_STATUS MSRS,  and Chapter …\nSee Section 15.3.2.3, IA32_MCi_ADDR MSRs.\nSee Section 15.3.2.1,  IA32_MCi_CTL MSRs.\nSee Section 15.3.2.4,  IA32_MCi_MISC MSRs.\nSee Section 15.3.2.2, IA32_MCi_STATUS MSRS,  and Chapter …\nSee Section 15.3.2.3, IA32_MCi_ADDR MSRs.\nSee Section 15.3.2.1,  IA32_MCi_CTL MSRs.\nSee Section 15.3.2.4,  IA32_MCi_MISC MSRs.\nSee Section 15.3.2.2, IA32_MCi_STATUS MSRS,  and Chapter …\nSee Section 15.3.2.3, IA32_MCi_ADDR MSRs.\nSee Section 15.3.2.1,  IA32_MCi_CTL MSRs.\nSee Section 15.3.2.4,  IA32_MCi_MISC MSRs.\nSee Section 15.3.2.2, IA32_MCi_STATUS MSRS,  and Chapter …\nSee Section 15.3.2.4,  IA32_MCi_MISC MSRs.\nSee Section 15.3.2.3, IA32_MCi_ADDR MSRs. The MSR_MC3_ADDR …\nSee Section 15.3.2.1,  IA32_MCi_CTL MSRs.\nSee Section 15.3.2.4,  IA32_MCi_MISC MSRs.\nSee Section 15.3.2.2, IA32_MCi_STATUS MSRS.\nSee Section 15.3.2.3, IA32_MCi_ADDR MSRs. The MSR_MC4_ADDR …\nSee Section 15.3.2.1,  IA32_MCi_CTL MSRs.\nAlways 0 (CMCI not supported).\nSee Section 15.3.2.4,  IA32_MCi_MISC MSRs.\nSee Section 15.3.2.2, IA32_MCi_STATUS MSRS.\nSee Section 15.3.2.3, IA32_MCi_ADDR MSRs. The MSR_MC4_ADDR …\nSee Section 15.3.2.1,  IA32_MCi_CTL MSRs.\nSee Section 15.3.2.4,  IA32_MCi_MISC MSRs.\nSee Section 15.3.2.2, IA32_MCi_STATUS MSRS,  and Chapter …\nSee Section 15.3.2.3, IA32_MCi_ADDR MSRs.\nSee Section 15.3.2.1,  IA32_MCi_CTL MSRs.\nSee Section 15.3.2.4,  IA32_MCi_MISC MSRs.\nApply to Intel Xeon processor 7400 series (processor …\nSee Section 15.3.2.3, IA32_MCi_ADDR MSRs.\nSee Section 15.3.2.1,  IA32_MCi_CTL MSRs.\nSee Section 15.3.2.4,  IA32_MCi_MISC MSRs.\nSee Section 15.3.2.2, IA32_MCi_STATUS MSRS,  and Chapter …\nSee Section 15.3.2.3, IA32_MCi_ADDR MSRs.\nSee Section 15.3.2.1,  IA32_MCi_CTL MSRs.\nSee Section 15.3.2.4,  IA32_MCi_MISC MSRs.\nSee Section 15.3.2.2, IA32_MCi_STATUS MSRS,  and Chapter …\nSee Section 15.3.2.3, IA32_MCi_ADDR MSRs.\nSee Section 15.3.2.1,  IA32_MCi_CTL MSRs.\nSee Section 15.3.2.4,  IA32_MCi_MISC MSRs.\nSee Section 15.3.2.2, IA32_MCi_STATUS MSRS,  and Chapter …\nMachine Check Miscellaneous See Section 15.3.2.6, IA32_MCG …\nMachine Check R10 See Section 15.3.2.6, IA32_MCG Extended  …\nMachine Check R11 See Section 15.3.2.6, IA32_MCG Extended  …\nMachine Check R12 See Section 15.3.2.6, IA32_MCG Extended  …\nMachine Check R13 See Section 15.3.2.6, IA32_MCG Extended  …\nMachine Check R14 See Section 15.3.2.6, IA32_MCG Extended  …\nMachine Check R8 See Section 15.3.2.6, IA32_MCG Extended  …\nMachine Check R9D/R9 See Section 15.3.2.6, IA32_MCG …\nMachine Check EAX/RAX Save State See Section 15.3.2.6, …\nMachine Check EBP/RBP Save State See Section 15.3.2.6, …\nMachine Check EBX/RBX Save State See Section 15.3.2.6, …\nMachine Check ECX/RCX Save State See Section 15.3.2.6, …\nMachine Check EDI/RDI Save State See Section 15.3.2.6, …\nMachine Check EDX/RDX Save State See Section 15.3.2.6, …\nMachine Check EFLAGS/RFLAG Save State See Section …\nMachine Check EIP/RIP Save State See Section 15.3.2.6, …\nMachine Check ESI/RSI Save State See Section 15.3.2.6, …\nSee http://biosbits.org.\nSee Section 18.12.1, ESCR MSRs.\nSee Section 18.12.1, ESCR MSRs.\nSee Section 18.12.3, CCCR MSRs.\nSee Section 18.12.3, CCCR MSRs.\nSee Section 18.12.3, CCCR MSRs.\nSee Section 18.12.3, CCCR MSRs.\nSee Section 18.12.2, Performance Counters.\nSee Section 18.12.2, Performance Counters.\nSee Section 18.12.2, Performance Counters.\nSee Section 18.12.2, Performance Counters.\nSee Section 18.12.1, ESCR MSRs.\nSee Section 18.12.1, ESCR MSRs.\nOffcore Response Event Select Register (R/W)\nOffcore Response Event Select Register (R/W)\nPrecise Event-Based Sampling (PEBS) (R/W)  Controls the …\nsee See Section 18.7.1.2, Load Latency Performance …\nSee Table 19-26.\nRO. This applies to processors that do not support …\nFixed-Function Performance Counter Register 0 (R/W)\nFixed-Function Performance Counter Register 1 (R/W)\nFixed-Function Performance Counter Register 2 (R/W)\nFixed-Function-Counter Control Register (R/W)\nSee Section 18.4.2, Global Counter Control Facilities.\nSee Section 18.4.2, Global Counter Control Facilities.\nSee Section 18.4.2, Global Counter Control Facilities.\nPackage C3 Interrupt Response Limit (R/W)  Note: C-state …\nPackage C6 Interrupt Response Limit (R/W)  This MSR …\nPackage C7 Interrupt Response Limit (R/W)  This MSR …\nNote: C-state values are processor specific C-state code …\nPackage C2 Residency Note: C-state values are processor …\nNote: C-state values are processor specific C-state code …\nPackage C4 Residency Note: C-state values are processor …\nNote: C-state values are processor specific C-state code …\nPackage C6 Residency Note: C-state values are processor …\nNote: C-state values are processor specific C-state code …\nNote: C-state values are processor specific C-state code …\nC-State Configuration Control (R/W)  Note: C-state values …\nPKG Energy Status (R/O)  See Section 14.7.3, Package RAPL …\nPackage RAPL Perf Status (R/O)\nPKG RAPL Parameters (R/W) See Section 14.7.3,  Package …\nPKG RAPL Power Limit Control (R/W)  See Section 14.7.3, …\nPlatform Feature Requirements (R)\nModel Specific Platform ID (R)\nsee http://biosbits.org.\nPower Management IO Redirection in C-state (R/W)  See …\nSee Section 18.12.1, ESCR MSRs.\nSee Section 18.12.1, ESCR MSRs.\nPower Control Register. See http://biosbits.org.\nPP0 Energy Status (R/O)  See Section 14.7.4, PP0/PP1 RAPL …\nPP0 Performance Throttling Status (R/O) See Section …\nPP0 Balance Policy (R/W)  See Section 14.7.4, PP0/PP1 RAPL …\nPP0 RAPL Power Limit Control (R/W)  See Section 14.7.4, …\nPP1 Energy Status (R/O)  See Section 14.7.4, PP0/PP1 RAPL …\nPP1 Balance Policy (R/W)  See Section 14.7.4, PP0/PP1 RAPL …\nPP1 RAPL Power Limit Control (R/W)  See Section 14.7.4, …\nUncore R-box 0 perfmon local box control MSR.\nUncore R-box 0 perfmon local box overflow control MSR.\nUncore R-box 0 perfmon local box status MSR.\nUncore R-box 0 perfmon counter MSR.\nUncore R-box 0 perfmon counter MSR.\nUncore R-box 0 perfmon counter MSR.\nUncore R-box 0 perfmon counter MSR.\nUncore R-box 0 perfmon counter MSR.\nUncore R-box 0 perfmon counter MSR.\nUncore R-box 0 perfmon counter MSR.\nUncore R-box 0 perfmon counter MSR.\nUncore R-box 0 perfmon event select MSR.\nUncore R-box 0 perfmon event select MSR.\nUncore R-box 0 perfmon event select MSR.\nUncore R-box 0 perfmon event select MSR.\nUncore R-box 0 perfmon event select MSR.\nUncore R-box 0 perfmon event select MSR.\nUncore R-box 0 perfmon event select MSR.\nUncore R-box 0 perfmon event select MSR.\nUncore R-box 0 perfmon IPERF0 unit Port 0 select MSR.\nUncore R-box 0 perfmon IPERF0 unit Port 1 select MSR.\nUncore R-box 0 perfmon IPERF0 unit Port 2 select MSR.\nUncore R-box 0 perfmon IPERF0 unit Port 3 select MSR.\nUncore R-box 0 perfmon IPERF0 unit Port 4 select MSR.\nUncore R-box 0 perfmon IPERF0 unit Port 5 select MSR.\nUncore R-box 0 perfmon IPERF0 unit Port 6 select MSR.\nUncore R-box 0 perfmon IPERF0 unit Port 7 select MSR.\nUncore R-box 0 perfmon QLX unit Port 0 select MSR.\nUncore R-box 0 perfmon QLX unit Port 1 select MSR.\nUncore R-box 0 perfmon QLX unit Port 2 select MSR.\nUncore R-box 0 perfmon QLX unit Port 3 select MSR.\nUncore R-box 1 perfmon local box control MSR.\nUncore R-box 1 perfmon local box overflow control MSR.\nUncore R-box 1 perfmon local box status MSR.\nUncore R-box 1 perfmon counter MSR.\nUncore R-box 1 perfmon counter MSR.\nUncore R-box 1 perfmon counter MSR.\nUncore R-box 1perfmon counter MSR.\nUncore R-box 1 perfmon counter MSR.\nUncore R-box 1 perfmon counter MSR.\nUncore R-box 1 perfmon counter MSR.\nUncore R-box 1 perfmon counter MSR.\nUncore R-box 1 perfmon event select MSR.\nUncore R-box 1 perfmon event select MSR.\nUncore R-box 1 perfmon event select MSR.\nUncore R-box 1 perfmon event select MSR.\nUncore R-box 1 perfmon event select MSR.\nUncore R-box 1 perfmon event select MSR.\nUncore R-box 1 perfmon event select MSR.\nUncore R-box 1 perfmon event select MSR.\nUncore R-box 1 perfmon IPERF1 unit Port 10 select MSR.\nUncore R-box 1 perfmon IPERF1 unit Port 11 select MSR.\nUncore R-box 1 perfmon IPERF1 unit Port 12 select MSR.\nUncore R-box 1 perfmon IPERF1 unit Port 13 select MSR.\nUncore R-box 1 perfmon IPERF1 unit Port 14 select MSR.\nUncore R-box 1 perfmon IPERF1 unit Port 15 select MSR.\nUncore R-box 1 perfmon IPERF1 unit Port 8 select MSR.\nUncore R-box 1 perfmon IPERF1 unit Port 9 select MSR.\nUncore R-box 1 perfmon QLX unit Port 4 select MSR.\nUncore R-box 1 perfmon QLX unit Port 5 select MSR.\nUncore R-box 1 perfmon QLX unit Port 6 select MSR.\nUncore R-box 1 perfmon QLX unit Port 7 select MSR.\nUnit Multipliers used in RAPL Interfaces (R/O)  See …\nSee Section 18.12.1, ESCR MSRs.\nSee Section 18.12.1, ESCR MSRs.\nUncore S-box 0 perfmon local box control MSR.\nUncore S-box 0 perfmon local box overflow control MSR.\nUncore S-box 0 perfmon local box status MSR.\nUncore S-box 0 perfmon counter MSR.\nUncore S-box 0 perfmon counter MSR.\nUncore S-box 0 perfmon counter MSR.\nUncore S-box 0 perfmon counter MSR.\nUncore S-box 0 perfmon event select MSR.\nUncore S-box 0 perfmon event select MSR.\nUncore S-box 0 perfmon event select MSR.\nUncore S-box 0 perfmon event select MSR.\nUncore S-box 0 perfmon local box mask MSR.\nUncore S-box 0 perfmon local box match MSR.\nUncore S-box 1 perfmon local box control MSR.\nUncore S-box 1 perfmon local box overflow control MSR.\nUncore S-box 1 perfmon local box status MSR.\nUncore S-box 1 perfmon counter MSR.\nUncore S-box 1 perfmon counter MSR.\nUncore S-box 1 perfmon counter MSR.\nUncore S-box 1 perfmon counter MSR.\nUncore S-box 1 perfmon event select MSR.\nUncore S-box 1 perfmon event select MSR.\nUncore S-box 1 perfmon event select MSR.\nUncore S-box 1 perfmon event select MSR.\nUncore S-box 1 perfmon local box mask MSR.\nUncore S-box 1 perfmon local box match MSR.\nSee Section 18.12.1, ESCR MSRs.\nSee Section 18.12.1, ESCR MSRs.\nSMI Counter (R/O)\nSMM Blocked (SMM-RO) Reports the blocked state of all …\nSMM Delayed (SMM-RO) Reports the interruptible state of …\nEnhanced SMM Feature Control (SMM-RW) Reports SMM …\nEnhanced SMM Capabilities (SMM-RO) Reports SMM capability …\nSystem Management Mode Physical Address Mask register  (WO …\nSee Section 18.12.1, ESCR MSRs.\nSee Section 18.12.1, ESCR MSRs.\nSee Section 18.12.1, ESCR MSRs.\nSee Section 18.12.1, ESCR MSRs.\nSee Section 18.12.1, ESCR MSRs.\nThermal Monitor 2 Control.\nConfigTDP Control (R/W)\nSee http://biosbits.org.\nMaximum Ratio Limit of Turbo Mode RO if MSR_PLATFORM_INFO.…\nSee Section 18.12.1, ESCR MSRs.\nSee Section 18.12.1, ESCR MSRs.\nSee Section 18.7.2.3, Uncore Address/Opcode Match MSR.\nSee Section 18.7.2.1, Uncore Performance Monitoring  …\nSee Section 18.7.2.1, Uncore Performance Monitoring  …\nSee Section 18.7.2.2, Uncore Performance Event …\nSee Section 18.7.2.2, Uncore Performance Event …\nSee Section 18.7.2.2, Uncore Performance Event …\nSee Section 18.7.2.2, Uncore Performance Event …\nSee Section 18.7.2.2, Uncore Performance Event …\nSee Section 18.7.2.2, Uncore Performance Event …\nSee Section 18.7.2.2, Uncore Performance Event …\nSee Section 18.7.2.2, Uncore Performance Event …\nSee Section 18.7.2.1, Uncore Performance Monitoring  …\nSee Section 18.7.2.1, Uncore Performance Monitoring  …\nSee Section 18.7.2.1, Uncore Performance Monitoring  …\nSee Section 18.7.2.2, Uncore Performance Event …\nSee Section 18.7.2.2, Uncore Performance Event …\nSee Section 18.7.2.2, Uncore Performance Event …\nSee Section 18.7.2.2, Uncore Performance Event …\nSee Section 18.7.2.2, Uncore Performance Event …\nSee Section 18.7.2.2, Uncore Performance Event …\nSee Section 18.7.2.2, Uncore Performance Event …\nSee Section 18.7.2.2, Uncore Performance Event …\nUncore Arb unit, counter 0 event select MSR\nUncore Arb unit, counter 1 event select MSR\nUncore Arb unit, performance counter 0\nUncore Arb unit, performance counter 1\nUncore C-Box 0, counter 0 event select MSR\nUncore C-Box 0, counter 1 event select MSR\nUncore C-Box 0, performance counter 0\nUncore C-Box 0, performance counter 1\nUncore C-Box 1, counter 0 event select MSR\nUncore C-Box 1, counter 1 event select MSR\nUncore C-Box 1, performance counter 0\nUncore C-Box 1, performance counter 1\nUncore C-Box 2, counter 0 event select MSR\nUncore C-Box 2, counter 1 event select MSR\nUncore C-Box 2, performance counter 0\nUncore C-Box 2, performance counter 1\nUncore C-Box 3, counter 0 event select MSR\nUncore C-Box 3, counter 1 event select MSR.\nUncore C-Box 3, performance counter 0.\nUncore C-Box 3, performance counter 1.\nUncore C-Box configuration information (R/O)\nUncore fixed counter\nUncore fixed counter control (R/W)\nUncore PMU global control\nUncore PMU main status\nUncore U-box perfmon counter MSR.\nUncore U-box perfmon event select MSR.\nUncore U-box perfmon global control MSR.\nUncore U-box perfmon global overflow control MSR.\nUncore U-box perfmon global status MSR.\nUncore W-box perfmon local box control MSR.\nUncore W-box perfmon local box overflow control MSR.\nUncore W-box perfmon local box status MSR.\nUncore W-box perfmon counter MSR.\nUncore W-box perfmon counter MSR.\nUncore W-box perfmon counter MSR.\nUncore W-box perfmon counter MSR.\nUncore W-box perfmon event select MSR.\nUncore W-box perfmon event select MSR.\nUncore W-box perfmon event select MSR.\nUncore W-box perfmon event select MSR.\nUncore W-box perfmon fixed counter\nUncore U-box perfmon fixed counter control MSR\nSee Section 35.16, MSRs in Pentium Processors,  and see  …\nSee Section 35.16, MSRs in Pentium Processors,  and see  …\nCS register target for CPL 0 code\nCPL 0 code entry point\nStack pointer for CPL 0 stack\nTest Control Register\nSee Section 17.13, Time-Stamp Counter.\nRead 64 bits msr register.\nWrite 64 bits to msr register.\nRdRand trait to implement the generic rdrand_slice …\nRdSeed trait to implement the generic rdseed_slice …\nFills <code>self</code> with random bits. Returns true on success or …\nFills <code>self</code> with random bits. Returns true on success or …\nGenerates a 16-bit random value and stores it in <code>e</code>.\nGenerates a 32-bit random value and stores it in <code>e</code>.\nGenerates a 64-bit random value and stores it in <code>e</code>.\nFill a slice with random values.\nGenerates a 16-bit random value and stores it in <code>e</code>.\nGenerates a 32-bit random value and stores it in <code>e</code>.\nGenerates a 64-bit random value and stores it in <code>e</code>.\nFill a slice with random values.\nCode Segment types for descriptors. See also Intel 3a, …\nData Segment types for descriptors. See also Intel 3a, …\nEntry for IDT, GDT or LDT. Provides size and location of a …\nMakes building descriptors easier (hopefully).\nCode Execute-Only\nCode Execute-Only, accessed\nCode Execute-Only, conforming\nCode Execute-Only, conforming, accessed\nCode Execute/Read\nCode Execute/Read, accessed\nCode Execute/Read, conforming\nCode Execute/Read, conforming, accessed\nTrait that defines the architecture specific functions for …\nTrait to define functions that build an architecture …\nRequestor Privilege Level\nData Read-Only, expand-down\nData Read-Only, expand-down, accessed\nData Read-Only\nData Read-Only, accessed\nData Read/Write\nData Read/Write, accessed\nData Read/Write, expand-down\nData Read/Write, expand-down, accessed\nTrait to define functions that build architecture specific …\nSpecifies which element to load into a segment from …\nSystem-Segment and Gate-Descriptor Types 32-bit mode. See …\nSystem-Segment and Gate-Descriptor Types 64-bit mode See …\nTable Indicator (TI) 0 means GDT is used.\nTable Indicator (TI) 1 means LDT is used.\nTrait to implement for building a task-gate (this …\nReturns the set containing all flags.\nToggle the AVL bit.\nReturns the intersection between the two sets of flags.\nDisables all flags disabled in the set.\nReturns the union of the two sets of flags.\nAdds the set of flags.\nReturns the raw value of the flags currently stored.\nReturns the left flags, but with all the right flags …\nToggles the set of flags.\nReturns the complement of this set of flags.\nReturns <code>true</code> if all of the flags in <code>other</code> are contained …\nReturns the current value of the code segment register.\nSet default operation size (false for 16bit segment, true …\nReturns the difference between the flags in <code>self</code> and <code>other</code>.\nSpecifies the privilege level of the segment.\nReturns the current value of the data segment register.\nReturns an empty set of flags.\nReturns the current value of the extra segment register.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert from underlying bit representation, unless that …\nConvert from underlying bit representation, dropping any …\nConvert from underlying bit representation, preserving all …\nMake a new segment selector from a untyped u16 value.\nReturns the current value of the FS segment register.\nReturns the current value of the GS segment register.\nReturns segment selector’s index in GDT or LDT.\nInserts the specified flags in-place.\nReturns the intersection between the flags in <code>self</code> and …\nReturns <code>true</code> if there are flags common to both <code>self</code> and …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if all flags are currently set.\nReturns <code>true</code> if no flags are currently stored.\nSet a the interrupt stack table index (only if this ends …\nSet L bit if this descriptor is a 64-bit code segment. In …\nThe segment limit is interpreted in 4-KByte units if this …")