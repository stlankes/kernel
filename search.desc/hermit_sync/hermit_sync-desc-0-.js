searchState.loadedDescShard("hermit_sync", 0, "Overview\nA synchronization primitive that can only be called once …\nThe <code>CallOnceError</code> error indicates that <code>CallOnce::call_once</code> …\nA synchronization primitive which can be accessed only …\nA <code>generic_once_cell::Lazy</code>, initialized using …\nA <code>lock_api::Mutex</code> based on <code>RawInterruptMutex</code>.\nA <code>lock_api::MutexGuard</code> based on <code>RawInterruptMutex</code>.\nA <code>generic_once_cell::OnceCell</code>, initialized using …\nA <code>lock_api::Mutex</code> based on <code>RawInterruptOneShotMutex</code>.\nA <code>lock_api::MutexGuard</code> based on <code>RawInterruptOneShotMutex</code>.\nA <code>lock_api::Mutex</code> based on <code>RawInterruptSpinMutex</code>.\nA <code>lock_api::MutexGuard</code> based on <code>RawInterruptSpinMutex</code>.\nA <code>lock_api::Mutex</code> based on <code>RawInterruptTicketMutex</code>.\nA <code>lock_api::MutexGuard</code> based on <code>RawInterruptTicketMutex</code>.\nA <code>generic_once_cell::Lazy</code>, initialized using <code>RawSpinMutex</code>.\nA <code>generic_once_cell::OnceCell</code>, initialized using …\nA <code>lock_api::Mutex</code> based on <code>RawOneShotMutex</code>.\nA <code>lock_api::MutexGuard</code> based on <code>RawOneShotMutex</code>.\nA <code>lock_api::RwLock</code> based on <code>RawOneShotRwLock</code>.\nA <code>lock_api::RwLockReadGuard</code> based on <code>RawOneShotRwLock</code>.\nA <code>lock_api::RwLockUpgradableReadGuard</code> based on …\nA <code>lock_api::RwLockWriteGuard</code> based on <code>RawOneShotRwLock</code>.\nA mutex for sharing data with interrupt handlers or signal …\nAn interrupt-safe <code>RawOneShotMutex</code>.\nAn interrupt-safe <code>RawSpinMutex</code>.\nAn interrupt-safe <code>RawTicketMutex</code>.\nA one-shot mutex that panics instead of (dead)locking on …\nA one-shot readers-writer lock that panics instead of …\nA simple spinning, read-preferring readers-writer lock …\nA simple spinlock with exponential backoff.\nA fair ticket lock with exponential backoff.\nA <code>lock_api::RwLock</code> based on <code>RawRwSpinLock</code>.\nA <code>lock_api::RwLockReadGuard</code> based on <code>RawRwSpinLock</code>.\nA <code>lock_api::RwLockUpgradableReadGuard</code> based on …\nA <code>lock_api::RwLockWriteGuard</code> based on <code>RawRwSpinLock</code>.\nA <code>lock_api::Mutex</code> based on <code>RawSpinMutex</code>.\nA <code>lock_api::MutexGuard</code> based on <code>RawSpinMutex</code>.\nA <code>lock_api::Mutex</code> based on <code>RawTicketMutex</code>.\nA <code>lock_api::MutexGuard</code> based on <code>RawTicketMutex</code>.\nMark this <code>CallOnce</code> as called.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns a mutable reference to the underlying data.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nUnwraps the value.\nReturns <code>true</code> if the mutable reference has been taken.\nCreates a new <code>CallOnce</code>.\nCreates a new <code>ExclusiveCell</code> containing the given value.\nTakes the mutable reference to the wrapped value.\nReturns <code>true</code> if <code>call_once</code> has been called.\nRun a closure with disabled interrupts.")